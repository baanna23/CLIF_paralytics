---
title: "cohort_identification_paralytic_use"
---

#Specify File Paths, Project Path and Site - SITE SPECIFIC
#Load the Required CLIF Tables (or if using ARROW/parquet refer to table in situ on storage drive)
```{r}

site_time_zone <-"America/New_York" #Add your local time zone prior to UTC conversion, options for this Analysis are EST = 'America/New_York', CST = 'America/Chicago', PST = 'America/Los_Angeles' 
tables_location <-"Z:/barker/clif_3_22/CLIF-2.0.0-dttm-update-R" #Add local path to CLIF tables
project_location <-"Z:/barker/clif_paralytics" #Add local path to project location, where results will output
site <-"Michigan" #Add local site name
file_type <-"parquet" #Options are "parquet" or "csv"

check_timezone <- function(site_timezone, intended_timezone = Sys.timezone()) {
  if (site_timezone != intended_timezone) {
    cat("Warning: You specified", site_timezone, "but your system time zone is", intended_timezone, "\n")
    response <- readline(prompt = "Was that intentional? (yes/no): ")
    
    if (tolower(response) %in% c("no", "n")) {
      new_timezone <- readline(prompt = "Please enter the correct timezone: ")
      cat("Timezone updated to", new_timezone, "\n")
      return(new_timezone)
    } else {
      cat("Proceeding with the originally specified timezone:", site_timezone, "\n")
      return(site_timezone)
    }
    
  } else {
    cat("Timezone is set to", site_timezone, "\n")
    return(site_timezone)
  }
}

#Time Zone Check
result <- check_timezone(site_time_zone)

#Create Sub Folders within Project Folder
# Check if the output directory exists; if not, create it
if (!dir.exists(paste0(project_location, "/project_tables"))) {
  dir.create(paste0(project_location, "/project_tables"))
}
if (!dir.exists(paste0(project_location, "/project_output"))) {
  dir.create(paste0(project_location, "/project_output"))
}
```


```{r Load Needed Libraries, include=FALSE}
packages <- c("duckdb", 
              "lubridate", 
              "tidyverse", 
              "dplyr",
              "table1", 
              "broom", 
              "arrow", 
              "rvest", 
              "readr", 
              "fst", 
              "data.table", 
              "collapse", 
              "tictoc", 
              "purrr")

install_if_missing <- function(package) {
  if (!require(package, character.only = TRUE)) {
    install.packages(package, dependencies = TRUE)
    library(package, character.only = TRUE)
  }
}

sapply(packages, install_if_missing)
rm(packages, install_if_missing)

#Use Dplyr select as default
select <- dplyr::select

```

```{r Keep Track of HOw Long this Markdown Takes to Run, Can Potentially Identify Issues}
tic()
```

#Objective: identify a cohort of hospitalizations with patients who receive mechanical ventilation from CLIF tables
Identify patients admitted to the hospital in a given date range. Export a list of `hospitalization_id` and filtered CLIF tables for the identified hospitalizations.

# Two patient cohorts, 1) overall IMV cohort to describe paralytic use and 2) rose specific cohort for target trial emulation 
1) Overall IMV cohort: 
Age >= 18 Years
First episode of IMV of any duration 
PF <=200 
Outcome either 1) continuous paralytic use at any time or 2) at least 1 intermittent dose of paralytics >1h after intubation

2) ROSE specific cohort for target trial emulation
Inclusion criteria: PF <=150 on PEEP >= 8, no FiO2 requirements
If no ABG, then include equivalent S/F ratio with confirmatory low S/F in 1-6 hours  
Criteria are met in the first 5 days of IMV initiation (t_rose_first)
AND
Exclusion criteria: Have not received >3h of continuous paralytics, >2 intermittent paralytic pushes after intubation (does not count RSI meds), cannot have do not intubate code status, not on ecmo at time of meeting inclusion criteria. Cannot be on chronic home mechanical ventilation (defined by trach within 24 hours of intubation)

## Date range
Specify the start and end dates for the cohort
```{r Start Times and Whether Pediatric Patients Are Included}
start_date <- as.POSIXct("2018-01-01", tz=site_time_zone)
end_date <- as.POSIXct("2024-12-31", tz=site_time_zone)

include_pediatric <- FALSE
include_er_deaths <- TRUE
```

#Specify required CLIF Tables
```{r}
#List of table names from CLIF 2.0
tables <- c("patient", "hospitalization", "vitals", "labs", 
            "medication_admin_continuous", "medication_admin_intermittent", "adt", 
            "patient_assessments", "respiratory_support", "position", 
            "dialysis", "intake_output", "ecmo_mcs", "procedures", 
            "admission_diagnosis", "provider", "sensitivity", 
            "medication_orders", "medication_admin_intermittent", 
            "therapy_details", "microbiology_culture", "sensitivity", "microbiology_nonculture", "code_status")

# Tables that should be set to TRUE for this project
true_tables <- c("patient", "hospitalization", "adt", "patient_assessments",
                 "vitals", "labs", "medication_admin_continuous", "medication_admin_intermittent", "respiratory_support",
                 "position", "microbiology_nonculture", "code_status")

# Create a named vector and set the boolean values
table_flags <- setNames(tables %in% true_tables, tables)
```


```{r}
# List all CLIF files in the directory
clif_table_filenames <- list.files(path = tables_location, 
                                   pattern = paste0("^clif_.*\\.", file_type, "$"), 
                                   full.names = TRUE)

# Extract the base names of the files (without extension)
clif_table_basenames <- basename(clif_table_filenames) |>
  str_remove(paste0("\\.", file_type, "$"))

# Create a lookup table for required files based on table_flags
required_files <- paste0("clif_", names(table_flags)[table_flags])

# Check if all required files are present
missing_tables <- setdiff(required_files, clif_table_basenames)
if (length(missing_tables) > 0) {
  stop(paste("Error: Missing required tables:", paste(missing_tables, collapse = ", ")))
}

# Filter only the filenames that are required
required_filenames <- clif_table_filenames[clif_table_basenames %in% required_files]

# Read the required files into a list of data frames
if (file_type == "parquet") {
  data_list <- lapply(required_filenames, open_dataset)
} else if (file_type == "csv") {
  data_list <- lapply(required_filenames, read_csv)
} else if (file_type == "fst") {
  data_list <- lapply(required_filenames, read.fst)
} else {
  stop("Unsupported file format")
}

# Assign the data frames to variables based on their file names
for (i in seq_along(required_filenames)) {
  # Extract the base name of the file (without extension)
  object_name <- str_remove(basename(required_filenames[i]), paste0("\\.", file_type, "$"))
  # Make the object name valid for R (replace invalid characters with underscores)
  object_name <- make.names(object_name)
  # Assign the tibble to a variable with the name of the file
  assign(object_name, data_list[[i]])
}
```

#Now Ready to Identify Cohort
#Identify Hospitalizations for Adults >= 18 Who Were Ever in an ED, Ward or ICU
#At This Stage Identify Encounters that Are 'Linked', that is continuous admission within the health system but in different hospitals (or sometimes ED to inpatient in same hospital)
#Script below will create an 'encounter_block' variable toto identify admissions at the patient_id level that are linked
```{r Identify Hospitalizations in Right Time Frame and Age}
clif_hospitalization <- clif_hospitalization |>
   mutate(hospitalization_id=as.character(hospitalization_id)) |>
   filter(admission_dttm >= start_date &
   admission_dttm <= end_date) |>
   compute()

if (!include_pediatric) {
  clif_hospitalization <- clif_hospitalization |>
    filter(age_at_admission >= 18) |>
    compute()
}

#To be Thorough Will Keep WARD, ICU and ER Encounters (in case of ED to ICU within one system) -> changed to new location_categories
inpatient_hospitalization_ids <- clif_adt |>
  mutate(hospitalization_id=as.character(hospitalization_id)) |>
  filter(tolower(location_category) %in% c("ward", "icu", "ed", "stepdown")) |>
  select(hospitalization_id) |>
  collect()

clif_hospitalization <- clif_hospitalization |>
  collect() |> #Have to Bring in to Environment To Correctly Filter IDs (at JHH)
  filter(hospitalization_id %in% inpatient_hospitalization_ids$hospitalization_id) |>
  as_arrow_table() #Put Back to Arrow Table
rm(inpatient_hospitalization_ids)

#Create an Hospital Block ID - This is to Identify Continuous Hospitalizations When Patients Are Transferred Between Hospitals in One Health System
#This code is intended be robust to various ways encounters may be coded in CLIF databases
hospital_blocks <- clif_hospitalization |>
  select(patient_id, hospitalization_id, admission_dttm, discharge_dttm) |>
  arrange(patient_id, admission_dttm) |>
  collect()

#Identify Admissions That Occur Within 3 Hours of a Discharge (Will Consider Those Linked and as Part of One Continuous Encounter)
#Use Data Table for Speed
linked_encounters <- setDT(hospital_blocks)
#Create a Variable for the time of the next admission and time of previous discharge
linked_encounters[, ':=' (next_admit_dttm = data.table::shift(admission_dttm, n=1, type = "lead")), by = patient_id]
linked_encounters[, ':=' (prev_dc_dttm = data.table::shift(discharge_dttm, n=1, type = "lag")), by = patient_id]
#Calculates Time Between Discharge and Next Admit
linked_encounters[, next_diff_time := difftime(next_admit_dttm, discharge_dttm, units = "hours")]
linked_encounters[, prev_diff_time := difftime(admission_dttm, prev_dc_dttm, units = "hours")]

#Now Create Variable Indicating a Linked Encounter (next_admit-dc time <6 hours or prev_dc-admint <6 hours)
linked_encounters[, linked := fcase(
  (next_diff_time <6 | prev_diff_time <6), 1)]
#Filter to Only Linked Encounters and number them
linked_encounters <- linked_encounters[linked==1]
#This Identifies the First Encounter in a Series of Linked Encounters
linked_encounters[, first_link := fcase(
  (rowid(linked)==1 | (next_diff_time<6 & prev_diff_time>6)), 1
), by = patient_id]
#Now Numbers Encounters, easier in dplyr
#Filter to Just First Links, Number them and then Remerge with linked encounters
temp <- as_tibble(linked_encounters) |>
 filter(first_link==1) |>
 group_by(patient_id) |>
 mutate(link_group=row_number()) |>
 ungroup() |>
 select(hospitalization_id, link_group) 
linked_encounters <- as_tibble(left_join(linked_encounters, temp, join_by(hospitalization_id))) |>
  fill(link_group, .direction = c("down")) |>
  #Create a Variable Indicating Which Number of LIinked Encounter the Encounter is
  group_by(patient_id, link_group) |>
  mutate(link_number=row_number()) |>
  ungroup() |>
  select(hospitalization_id, linked, link_number)
rm(temp)

#Now Join Back to Hospitalization Table
clif_hospitalization <- clif_hospitalization |>
  left_join(linked_encounters) |>
  mutate(linked=if_else(is.na(linked), 0, linked)) |>
  compute()

#Pull Out the Any Linked Encounter that Is NOt the First Encounter and Assign Each Encounter an Encounter Block ID in the Original clif_hospitalization table
df_link <- clif_hospitalization |>
  filter(link_number>1) |>
  collect()

clif_hospitalization <- clif_hospitalization |>
  group_by(patient_id) |>
  arrange(patient_id, admission_dttm) |>
  #Remove Link Numbers that Are Not First in Link Encounter
  filter(link_number==1 | is.na(link_number)) |>
  #Make Encounter Blocks
  collect() |>
  mutate(encounter_block=row_number()) |>
  rowbind(df_link, fill = TRUE) |> #Bring Back in Link Numbers >1
  group_by(patient_id) |> arrange(patient_id, admission_dttm) |>
  fill(encounter_block, .direction = "down") |>
  ungroup()|>
  #Finally, for Linked Encounters Identify 'Final_admit_date' and 'final_dc_date' which are the first and last dates of a link block
  group_by(patient_id, encounter_block) |>
  mutate(final_admission_dttm=fcase(
    row_number()==1, as.POSIXct(admission_dttm)
  )) |>
  mutate(final_discharge_dttm=fcase(
    row_number()==n(), as.POSIXct(discharge_dttm)
  )) |>
  mutate(final_discharge_category=fcase(
    row_number()==n(), discharge_category
  )) |>
  mutate(final_discharge_name=fcase(
    row_number()==n(), discharge_name
  )) |>
  fill(final_admission_dttm, 
       final_discharge_dttm,
       final_discharge_name, 
       final_discharge_category, 
       .direction = 'updown') |>
  relocate(encounter_block, .after = 'hospitalization_id') |>
  as_arrow_table()

rm(linked_encounters, df_link, hospital_blocks)

#Keep Track for Consort Diagram
patients <- length(unique(clif_hospitalization$patient_id))
encounters <- length(clif_hospitalization$hospitalization_id)
cat('\n In', site, 'CLIF data there are', patients,'unique patients with', encounters, 'encounters \n')
```

#Filter Only to Patients Who Receive Mechanical Ventilation
```{r}
#Bring in Temporary File with patient_id, hospitalization_id and encounter_block
temp_ids <- clif_hospitalization |>
  select(patient_id, hospitalization_id, encounter_block) |>
  collect()

#Identify Patients Who EVER Received Mechanical Ventilation During a Hospitalization
vent <- clif_respiratory_support |>
  mutate(hospitalization_id=as.character(hospitalization_id)) |>
  #Only Need IDs in the Current Working ClIF hospitalization Table
  filter(hospitalization_id %in% temp_ids$hospitalization_id) |>
  #Will Also Merge in Encounter Block Here - Will Allow Us to Keep Track of LInked Encounters
  left_join(temp_ids) |>
  compute()
rm(temp_ids)

#Identify Those Who Have Ever Been on a Vent During an Encounter Block
vent <- vent |> 
  mutate(on_vent=if_else(tolower(device_category)=='imv', 1, 0)) |>
  group_by(patient_id, encounter_block) |>
  mutate(ever_vent=if_else(max(on_vent, na.rm=T)==1, 1, 0)) |>
  filter(ever_vent==1) |>
  select(-ever_vent) |>
  ungroup() |>
  compute()

#Identify First Vent Start Time and Vent Duration
#Keep Track for Consort Diagram
patients <- length(unique(vent$patient_id))
encounters <- length(unique(vent$hospitalization_id))
cat('\n Paitents Receiving Mechanical Ventilation: \n  In', site, 'CLIF data there are', patients,'unique patients with', encounters, 'encounters \n')
```

#Identify Ventilator Episodes
```{r}
#Now Identify Ventilator Episodes and the Duration of Each Episodes
vent <- vent |>
  mutate(
    device_category = 
    if_else(
        is.na(device_category) & is.na(device_name) &
          str_detect(tolower(mode_category), 
                     "pressure control|assist control-volume control|pressure support/cpap|pressure-regulated volume control|simv"),
        "IMV",
        device_category
      ),
    device_name = 
      if_else(
        str_detect(tolower(device_category), "imv") & is.na(device_name) &
          str_detect(tolower(mode_category), 
                     "pressure control|assist control-volume control|pressure support/cpap|pressure-regulated volume control|simv"),
        "IMV",
        device_name
      ),
  ) |>
  collect() |>
  #     If device before is VENT + normal vent things ... its VENT too 
  group_by(patient_id, encounter_block) |>
  arrange(patient_id, recorded_dttm) |>
  mutate(device_category = fifelse(is.na(device_category) & 
                                     lag(tolower(device_category) == "imv") & 
                                     tidal_volume_set > 1 & 
                                     resp_rate_set > 1 & 
                                     peep_set > 1, 
                                   "IMV", 
                                   device_category)) |>
  # If device after is VENT + normal vent things ... its VENT too 
  mutate(device_category = fifelse(is.na(device_category) & 
                                     lead(tolower(device_category) == "imv") & 
                                     tidal_volume_set > 1 & 
                                     resp_rate_set > 1 & 
                                     peep_set > 1, 
                                   "IMV", 
                                   device_category)) |>
  # doing this for BiPAP as well
  mutate(device_category = fifelse(is.na(device_category) & 
                                     lag(tolower(device_category) == "nippv") & 
                                     #minute_vent > 1 & 
                                     pressure_support_set > 1, 
                                   "NIPPV", 
                                   device_category)) |>
  
  mutate(device_category = fifelse(is.na(device_category) & 
                                     lead(tolower(device_category) == "nippv") & 
                                     #minute_vent > 1 & 
                                     pressure_support_set > 1, 
                                   "NIPPV", 
                                   device_category)) |>
  ungroup()
  
# Now use a Fill Forward Method with Device Category
vent <- vent |>
  group_by(patient_id, encounter_block) |>
  fill(device_category, .direction = 'downup') |>
  ungroup() |>
  as_arrow_table()

#Goal of Function Below is to Define Ventilator Episodes & Ventilator Liberations (> 24 Hours off of MV)
#First will Filter Down to Reduced Table of 'device_category' transitions; For example: This includes rows when a device_category switches from one to another; Also keep First and Last Rows
device_transitions <- vent |> 
  arrange(patient_id, recorded_dttm) |> #Puts in Correct Order
  collect() |>
  group_by(patient_id, encounter_block) |>
  mutate(prev_value_diff = fifelse(
    (device_category!=data.table::shift(device_category, n=1, type = "lag")), 1, 0)) |>
  mutate(prev_value_diff=fifelse(is.na(prev_value_diff), 0, prev_value_diff)) |> #For First Row
  filter(prev_value_diff == 1 |
           row_number()==1 | row_number() == n()) |>
  ungroup()

#Define Ventilator Episodes - Define Ventilator Liberation as 24 Hours Breathing Off Ventilator, Otherwise Will Include That Time in Ventilator Duration
#For Patients Who Start IMV on Last Row can Calculate Time on Vent Using Final Discharge Time
dc_time <- clif_hospitalization |>
  select(patient_id, encounter_block, final_discharge_dttm) |>
  distinct()  |> #1 Row for 1 Encounter Block 
  collect()

#Temporarily Number Vent Episodes
device_transitions <- device_transitions |>
  join(dc_time, how = 'left') |>
  group_by(patient_id, encounter_block, device_category) |>
  mutate(category_number=row_number()) |>
  #If a Last Row of an Enconter Block is Not a Device Transition Set Category Number to NA
  group_by(patient_id, encounter_block) |>
  mutate(category_number=fifelse(
    row_number()==n() & prev_value_diff!=1, NaN, category_number
  )) |>
  ungroup() |>
  group_by(patient_id, encounter_block) |>
#Define Vent Start and Stop (Temporary)
  mutate(vent_start=fcase(
    tolower(device_category)=='imv' & (prev_value_diff==1 | row_number()==1), recorded_dttm
  )) |>
  mutate(vent_stop=fcase(
    tolower(device_category)=='imv' & lead(prev_value_diff)==1, lead(recorded_dttm),
    tolower(device_category)=='imv' & lead(row_number())==n(), lead(recorded_dttm), #This is Why we Kept Last Row
    #If the Last Row is 'IMV' Than Use Discharge Time 
    row_number()==n() & tolower(device_category)=='imv', final_discharge_dttm
  )) |>
  fill(vent_stop, .direction = 'down') |>
  #Define Vent Liberation of Prior Vent Episodes as 24 Hours without device_category=='IMV', can fill backwards for this
  mutate(prior_liberation_new_vent=fcase(
    #This says if the next time someone is on a vent > 24 hours after the last time on a vent it will be a new episode
    tolower(device_category)=='imv' & category_number==1, 1, #Need to Define This First
    tolower(device_category)=='imv' & recorded_dttm>as.POSIXct(lag(vent_stop))+dhours(24), 1,
    tolower(device_category)=='imv' & recorded_dttm<=as.POSIXct(lag(vent_stop))+dhours(24), 0
  )) |>
  #Label if Last Row so Vent Duration Can be Defined by Discharge Time
  mutate(last_row=fifelse(row_number()==n(), 1, 0)) |>
  ungroup()

device_transitions <- device_transitions |>
  #Alternative Way of Labelling Liberation
  group_by(patient_id, encounter_block) |>
  mutate(vent_stop=fifelse(
    tolower(device_category)=='imv' & is.na(vent_stop) & last_row==1, final_discharge_dttm, as.POSIXct(vent_stop))) |>
  mutate(liberation=fcase(
    tolower(device_category)!='imv' & recorded_dttm>as.POSIXct(vent_stop)+dhours(24), 1,
    tolower(device_category)=='imv' & last_row==1, 0
  )) |>
  fill(liberation, .direction = 'up') |>
  ungroup()
rm(dc_time)

#Renumber 'New' Episodes of MV, that is if the first episode, and then episodes in which the patient was previously liberated, keep the intervening episodes so we can count final duration
vent_episodes <- device_transitions |>
  filter(tolower(device_category)=='imv') |>
  group_by(patient_id, encounter_block, prior_liberation_new_vent) |>
  mutate(vent_episode_number=fifelse(
    prior_liberation_new_vent==1, row_number(), NaN)) |>
  group_by(patient_id, encounter_block) |>
  fill(vent_episode_number, .direction = 'down') |>
  group_by(patient_id, encounter_block, vent_episode_number) |>
  mutate(vent_episode_start=fcase(
    row_number()==1, as.POSIXct(vent_start)
  )) |>
  mutate(vent_episode_end=fcase(
    row_number()==n(), as.POSIXct(vent_stop)
  )) |>
  mutate(liberation=fcase(
    row_number()==n(), liberation,
    default = NaN
  )) |>
  fill(vent_episode_start, vent_episode_end, liberation, mode_category, .direction = 'downup') |>
  #Now Keep First Row for Each Vent Episode
  filter(row_number()==1) |>
  ungroup() |>
  #Calculate Vent Duration
  mutate(vent_duration_hours=as.duration(vent_episode_end-vent_episode_start)/dhours(1)) |>
  select(patient_id, hospitalization_id, encounter_block, device_category, mode_category, 
         liberation, vent_duration_hours, vent_episode_number, vent_episode_end, vent_episode_start)

#Describe Numbers
cat('\nAt this stage in', site, 'data there are', dim(vent_episodes)[1], 'ventilator episodes among', 
    length(unique(vent_episodes$hospitalization_id)), 'hospitalizations from', 
    length(unique(vent_episodes$patient_id)), 'patients.')

#Now Filter to Just First Vent Episodes that are Greater than 0 Hours Long, no limitation on initial duration of episode
vent_eligible <- vent_episodes |>
  group_by(patient_id, encounter_block) |>
  filter(vent_episode_number==1 & vent_duration_hours>0) |>
  ungroup()

#Describe Numbers
cat(site, '\n After filtering to patients with >0 hours of MV for First Episode there are,', dim(vent_eligible)[1], 'ventilator episodes among,',length(unique(vent_eligible$hospitalization_id)), 'hospitalizations from',length(unique(vent_eligible$patient_id)), 'patients.')

rm(device_transitions)
```
#EXCLUSIONS (Overall and ROSE cohort):
-Tracheostomy prior to completing first 24 hours of first vent (includes tracheostomy on admission). 
-Patient admitted from OSH on the vent

-After Final Identification of ABG criteria will then randomly select 1 eligible encounter for each patient with more than 1 eligible, will eventually exclude patients with DNI, ecmo, prior paralytics at time of meeting criteria for ROSE cohort
```{r Implement Exclusion Criteria}
#List of patient_id, encounter_block, hospitalization_id and vent_start
temp_ids <- vent_eligible |>
  select(patient_id, encounter_block) |>
  mutate(in_cohort=1)
#Create a Table Containing the 3 Identifiers c('patient_id', 'hospitalization_id', 'encounter_block')
cohort_ids <- clif_hospitalization |>
  mutate(hospitalization_id=as.character(hospitalization_id)) |>
  left_join(temp_ids) |>
  filter(in_cohort==1) |>
  select(patient_id, hospitalization_id, encounter_block, in_cohort) |>
  collect()
rm(temp_ids)

#Tracheostomy in First 24 Hours of First Vent 
trach <- clif_respiratory_support |>
  left_join(cohort_ids) |>
  filter(in_cohort==1) |> #This allows us to keep all encounter block info
  select(patient_id, recorded_dttm, encounter_block, tracheostomy) |>
  filter(tracheostomy==1) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>
  collect() |>
  group_by(patient_id, encounter_block) |>
  filter(row_number()==1) |>
  mutate(first_trach_time=fcase(
    row_number()==1, as.POSIXct(recorded_dttm)
  )) |>
  ungroup() |>
  select(patient_id, encounter_block, tracheostomy, first_trach_time)

#Merge with Vent Eligible and Exclude if first_trach_time within 24 hours of vent start
vent_eligible <- vent_eligible |>
  join(trach, how = 'left') |>
  mutate(tracheostomy=fifelse(is.na(tracheostomy), 0, tracheostomy)) |> #If not merged indicates no trach performed
  mutate(trach_within_24=fcase(
    as.POSIXct(vent_episode_start)+dhours(24)>first_trach_time, 1,
    default = 0
  ))

#Describe for Consort
cat('\n At', site,',', length(unique(vent_eligible$hospitalization_id[vent_eligible$tracheostomy==1])), 'patient hospitalizations were ventilated via a tracheostomy,', length(unique(vent_eligible$hospitalization_id[vent_eligible$trach_within_24==1])), 'within 24 hours of ventilator start and are thus excluded. \n')

#Vent Eligible Excluding Early Trach
vent_eligible <- vent_eligible |>
  filter(trach_within_24!=1)
#rm(trach)
#Update Cohort_IDs
#List of patient_id, encounter_block, hospitalization_id and vent_start
temp_ids <- vent_eligible |>
  select(patient_id, encounter_block) |>
  mutate(in_cohort=1)
#Create a Table Containing the 3 Identifiers c('patient_id', 'hospitalization_id', 'encounter_block')
cohort_ids <- clif_hospitalization |>
  mutate(hospitalization_id=as.character(hospitalization_id)) |>
  left_join(temp_ids) |>
  filter(in_cohort==1) |>
  select(patient_id, hospitalization_id, encounter_block, in_cohort) |>
  collect()
rm(temp_ids)

#How Many Patients Arrive First to ICU and First Device is a Vent?
#First Define What the First Location Is
osh_transfer <- clif_adt |>
  mutate(hospitalization_id=as.character(hospitalization_id)) |>
  left_join(cohort_ids) |> #Here need to join first and then filter to those in cohort
  filter(in_cohort==1) |>
  arrange(patient_id, encounter_block, in_dttm) |>
  collect() |>
  group_by(patient_id, encounter_block) |> # Replace group_column with the column(s) you want to group by
  filter(row_number()==1) |>
  ungroup() |>
  mutate(first_location=location_category)

#Now Define First Device Category
first_device <- clif_respiratory_support |>
  mutate(hospitalization_id=as.character(hospitalization_id)) |>
  left_join(cohort_ids) |> #Here need to join first and then filter to those in cohort
  filter(in_cohort==1) |>
  filter(!is.na(device_category)) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>
  collect() |>
  group_by(patient_id, encounter_block) |>
  filter(row_number()==1) |>
  mutate(first_device=device_category) |>
  select(patient_id, encounter_block, first_device)

#Merge back with OSH
osh_transfer <- osh_transfer |>
  join(first_device, how ='left') |>
  mutate(transfer_on_vent=fifelse(
    tolower(first_location)=='icu' & first_device=='IMV', 1, 0
  )) |>
  select(patient_id, encounter_block, transfer_on_vent)

#Merge Into Vent Eligible
vent_eligible <- vent_eligible |>
  left_join(osh_transfer, join_by(patient_id, encounter_block)) 
rm(osh_transfer, first_device)

#Describe for Consort
cat('\n At', site,',', length(unique(vent_eligible$hospitalization_id[vent_eligible$transfer_on_vent==1])), 'patient hospitalizations were from patients who met criteria for having been transfered while on a ventilator and are thus excluded,') 

#Current Vent Eligible Cohort
vent_eligible <- vent_eligible |>
  filter(transfer_on_vent!=1)
cat('this yields an eligible ventilator cohort of,', length(unique(vent_eligible$hospitalization_id)), 'hospitalizations, among',
              length(unique(vent_eligible$patient_id)), 'patients. \n')     

#Update Running Table of Cohort IDs
#List of patient_id, encounter_block, hospitalization_id and vent_start
temp_ids <- vent_eligible |>
  select(patient_id, encounter_block) |>
  mutate(in_cohort=1)
#Create a Table Containing the 3 Identifiers c('patient_id', 'hospitalization_id', 'encounter_block')
cohort_ids <- clif_hospitalization |>
  mutate(hospitalization_id=as.character(hospitalization_id)) |>
  left_join(temp_ids) |>
  filter(in_cohort==1) |>
  select(patient_id, hospitalization_id, encounter_block, in_cohort) |>
  collect()
rm(temp_ids)
```

```{r Clean CLIF Labs Data for PaO2 and Merge with Respiratory Support for P/F Ratios}
#Will Use cohort_ids table and vent start to filter to relevant hospitalizations and times
vent_times <- vent_eligible |>
  select(patient_id, encounter_block, vent_episode_end, vent_episode_start,first_trach_time, vent_duration_hours, liberation)

#Filter Labs Table to Just Hospitaliztion IDs in the Cohort
clif_labs <- clif_labs |>
  mutate(hospitalization_id=as.character(hospitalization_id)) |>
  left_join(cohort_ids) |> #NOTE: clif_labs will now include patient_id and encounter_block
  filter(in_cohort==1) |>
  select(-in_cohort) |>
  compute()

#PaO2 Table
pao2 <- clif_labs |>
  mutate(hospitalization_id=as.character(hospitalization_id)) |>
  filter(lab_category=='po2_arterial' & !is.na(lab_value)) |>
  filter(lab_value!='NULL') |>
  filter(lab_value_numeric>40 & lab_value_numeric<=700) |> #Lower Bound Filtering for PaO2 Outliers > 40 and upper bound assumes FiO2 of 1.0 A-a gradient of 0 and Paco2 of 10
  distinct() |>
  select(patient_id, encounter_block, lab_collect_dttm, lab_value_numeric) |>
  collect() |>
  mutate(recorded_dttm=as.POSIXct(lab_collect_dttm, tz="UTC")) |> #For Merging with Vent Data
  rename(pao2 = lab_value_numeric) 

# Check fio2_set 
fio2_mean <- clif_respiratory_support |> 
  select(fio2_set) |> summarise(fio2_mean = mean(fio2_set, na.rm = TRUE)) |> collect() # fixing if its less than one # You will get a warning but it will be fixed on its own with IF statement 
if(fio2_mean > 1){ 
  clif_respiratory_support <- clif_respiratory_support |> mutate(fio2_set = fio2_set / 100) |> compute() }

#Create Vent Data Table for the First Ventilator Episode (the One being analyzed for this study)
#Merge in PaO2 Data Here
vent_data <- clif_respiratory_support |>
  mutate(hospitalization_id=as.character(hospitalization_id)) |>
  left_join(cohort_ids) |>
  filter(in_cohort==1) |>
  left_join(vent_times) |>
  collect() |>
  mutate(recorded_dttm=as.POSIXct(recorded_dttm, tz = 'UTC')) |>
  filter(recorded_dttm>=as.POSIXct(vent_episode_start, tz="UTC") & recorded_dttm<=as.POSIXct(vent_episode_end, tz="UTC")) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>  
  group_by(patient_id, encounter_block) |>
  fill(device_category, device_name, .direction = 'down') |>
  mutate(recorded_dttm=as.POSIXct(recorded_dttm, tz= 'UTC')) |> #to merge with pao2 data
  ungroup() |>
  #Bring in PaO2 Here and Then Fill Again
  join(pao2, how ='full') |>
  group_by(patient_id, encounter_block) |>
  fill(vent_episode_end, vent_episode_start, .direction = 'downup') |>
  filter(recorded_dttm>=as.POSIXct(vent_episode_start, tz="UTC") & recorded_dttm<=as.POSIXct(vent_episode_end, tz="UTC")) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>  
  fill(device_category, device_name, .direction = 'down') |>
  #Now Group by Patient/Encounter/device_category and fill peep and fio2
  group_by(patient_id, encounter_block, device_category) |>
  mutate(ever_tracheostomy=tracheostomy) |>
  fill(peep_set, 
       fio2_set, 
       resp_rate_set,
       tidal_volume_set,
       vent_episode_start,
       vent_episode_end,
       mode_category,
       first_trach_time,
       liberation,
       vent_duration_hours,
       hospitalization_id,
       ever_tracheostomy,
       .direction = 'downup') |> #will fill down first, then for start of IMV episode, will fill up for the few that are missing prior to first documentation
  fill(tracheostomy, .direction= 'down') |>
    ungroup() 

#Convert SpO2 to PaO2_i for calculation of imputed P/F ratios, use non-linear conversion (Brown et al, CCM 2018)
#Filter Labs Table to Just Hospitaliztion IDs in the Cohort
clif_vitals <- clif_vitals |>
  mutate(hospitalization_id = as.character(hospitalization_id))

clif_vitals <- clif_vitals |>
  left_join(cohort_ids) |> #NOTE: clif_vitals will now include patient_id and encounter_block
  filter(in_cohort==1) |>
  select(-in_cohort) |>
  compute()

#PaO2 Table
pao2_i <- clif_vitals |>
  filter(vital_category=='spo2' & !is.na(vital_value)) |>
  filter(vital_value!='NULL') |>
  filter(vital_value>60 & vital_value<=100) |> #Lower Bound Filtering for SpO2 Outliers > 60 and <=100 
  distinct() |>
  select(patient_id, encounter_block, recorded_dttm, vital_value) |>
  collect() |>
  mutate(recorded_dttm=as.POSIXct(recorded_dttm, tz="UTC")) |> #For Merging with Vent Data
  rename(spo2 = vital_value) 

vent_data <- vent_data |>
  #Bring in spo2 and pao2_i Here and Then Fill Again
  join(pao2_i, how ='full') |>
  filter(recorded_dttm>=as.POSIXct(vent_episode_start, tz="UTC") & recorded_dttm<=as.POSIXct(vent_episode_end, tz="UTC")) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>  
  mutate(pao2_i= case_when(spo2== 96~82, spo2==95~76, spo2==94~71, spo2==93~67, spo2==92~64, spo2==91~61, spo2==90~59, spo2==89~57, spo2==88~55, spo2==87~53, spo2==86~51, spo2==85~50, spo2==84~49, spo2==83~47, spo2==82~46, spo2==81~45, spo2==80~44, spo2==79~43, spo2==78| spo2==77~42, spo2==76~41, spo2==75~40, spo2==74|spo2==73~39, spo2==72~38, spo2==71|spo2==70~37)) |>
  ungroup() 

#Quality Check FiO2 and PEEP Data
#Calculate PF
#Indicate if 'rose_eligible' per P/F and S/F (will need repeat level if S/F criteria)
vent_data <- vent_data |>
  mutate(fio2_set=fifelse(
  fio2_set<0.21 | fio2_set>1, NaN, fio2_set)) |>
#     fio2_set<21 | fio2_set>100, NaN, fio2_set/100)) |>
  mutate(peep_set=fifelse(
    peep_set<0 | peep_set>35, NaN, peep_set)) |>
  #Now Calculate PF Ratios
  mutate(pf_ratio=pao2/fio2_set) |>
  #Now Calculate SF Ratios
  mutate(sf_ratio=pao2_i/fio2_set) |>
  #Indicate if ROSE Eligible - This Should ALL be During Vent Episode
  mutate(rose_eligible_pf=fcase(
    is.na(pao2)  | is.na(peep_set), NaN,
    pf_ratio<150 & peep_set>=8, 1,
    !is.na(pf_ratio) & (pf_ratio>=150 | peep_set<8), 0)) |>
  mutate(rose_eligible_sf=fcase(
    is.na(pao2_i)  | is.na(peep_set), NaN,
    sf_ratio<150 & peep_set>=8, 1,
    !is.na(sf_ratio) & (sf_ratio>=150 | peep_set<8), 0)) |>
  mutate(rose_eligible=fcase(
    (rose_eligible_sf == 0 & is.nan(rose_eligible_pf)), 0,
    rose_eligible_pf == 0, 0,
    is.nan(rose_eligible_pf)  & is.nan(rose_eligible_sf), NaN,
    rose_eligible_pf==1, 1,
    (rose_eligible_sf == 1 & is.nan(rose_eligible_pf)), 1))

vent_data <- unique(vent_data) #this takes awhile

#Keep Track of How Many ABGs During Eligible Vent Episode and How Many ROSE Eligible
pf_table <- vent_data |>
  filter(!is.na(pf_ratio)) |>
  mutate(n_pfs = n()) |>
  group_by(rose_eligible_pf) |>
  mutate(n_rose_eligible_pf=n()) |>
  ungroup() |>
  mutate(n_rose_eligible_pf=fifelse(
    rose_eligible_pf==1, n_rose_eligible_pf, NaN)) |>
  fill(n_rose_eligible_pf, .direction = 'updown') |>
  summarise(
    '# PF Ratios' = mean(n_pfs),
    '# ROSE Eligible by P/F' = mean(n_rose_eligible_pf),
    '% ROSE Eligible by P/F' = round(mean(n_rose_eligible_pf/n_pfs)*100, digits= 2)
  )
pf_table
#write_csv(pf_table, paste0(project_location, "/project_output/",site, "_pfratio_sample_size.csv"))
rm(pf_table, pao2, pao2_i)
```


```{r Implement ROSE Inclusion Criteria}
rose_criteria <- vent_data |>
  filter(!is.na(pf_ratio) | !(is.na(sf_ratio))) |>
  #Filter to First 126 Hours After Vent Start (120 hr for MV then 6hr for confirmatory S/F). P/F and S/F measured after first 1/2 hour, to limit documentation from pre-intubation that is hold over
  filter((recorded_dttm>=as.POSIXct(vent_episode_start, tz="UTC")+dhours(.5))  & (recorded_dttm<=as.POSIXct(vent_episode_start, tz="UTC")+dhours(126))) |>
  mutate(temp_rose_time=fifelse(
    rose_eligible==1 & recorded_dttm<=as.POSIXct(vent_episode_start, tz="UTC")+dhours(120), 1, 0
  )) |>
  group_by(patient_id, encounter_block, temp_rose_time, rose_eligible) |> #By grouping together can define the 1st PF ratios that Meet ROSE criteria
  arrange(patient_id, encounter_block, recorded_dttm) |>
  mutate(temp_pf=row_number()) |>
  ungroup() |>
  #Identify the PF ratio, FIo2, PEEP, and Mode Where ROSE Criteria First met
  mutate(first_rose_pf=fcase(
    temp_pf==1 & rose_eligible==1 & temp_rose_time==1, pf_ratio
  )) |>
  mutate(first_rose_sf=fcase(
    temp_pf==1 & rose_eligible==1 & temp_rose_time==1, sf_ratio
  )) |>
  mutate(first_rose_fio2=fcase(
    temp_pf==1 & rose_eligible==1 & temp_rose_time==1, fio2_set
  )) |>
  mutate(first_rose_peep=fcase(
    temp_pf==1 & rose_eligible==1 & temp_rose_time==1, peep_set
  )) |>
  mutate(first_rose_mode=fcase(
    temp_pf==1 & rose_eligible==1 & temp_rose_time==1, mode_category
  )) |>
  mutate(t_rose_first=fcase(
    temp_pf==1 & rose_eligible==1 & temp_rose_time==1, recorded_dttm
  )) |>
  mutate(criteria=fifelse(t_rose_first==recorded_dttm & rose_eligible_pf==1, "pf", NA)) |>
  group_by(patient_id, encounter_block) |>
  fill(first_rose_pf,
       first_rose_sf, 
       first_rose_fio2,
       first_rose_peep,
       first_rose_mode,
       t_rose_first,
       criteria,
       .direction = 'updown') |>
  ungroup() |>
  collect()

  #Now for patients qualifying with S/F Repeat For The 2nd Eligible Time - Must be within 1-6 Hours t_rose_first if s/f is what qualifies you
  #This Table is Already Windowed to First 126 Hours of Vent and Ends When patient is extubated/dies/transfers (if before 126 hours)
  rose_criteria_sf <- rose_criteria |>
  filter(is.na(first_rose_pf)) |> #potentially eligible based on s/f

  mutate(eligible_rose_t2=fifelse(
    recorded_dttm>=as.POSIXct(t_rose_first, tz="UTC")+dhours(1) & 
    recorded_dttm<=as.POSIXct(t_rose_first, tz="UTC")+dhours(6), 1, 0 # since this is set as 0 when not true, fill updown doesn't overwrite it. 
  )) |>
  group_by(patient_id, encounter_block, eligible_rose_t2, rose_eligible) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>
  mutate(temp_pf=row_number()) |>
  ungroup() |>
  mutate(second_rose_pf=fcase(
    temp_pf==1 & rose_eligible==1 & eligible_rose_t2, pf_ratio
  )) |>
  mutate(second_rose_sf=fcase(
    temp_pf==1 & rose_eligible==1 & eligible_rose_t2, sf_ratio
  )) |>
  mutate(second_rose_fio2=fcase(
    temp_pf==1 & rose_eligible==1 & eligible_rose_t2, fio2_set
  )) |>
  mutate(second_rose_peep=fcase(
    temp_pf==1 & rose_eligible==1 & eligible_rose_t2, peep_set
  )) |>
  mutate(second_rose_mode=fcase(
    temp_pf==1 & rose_eligible==1 & eligible_rose_t2, mode_category
  )) |>
  mutate(t_rose_second=fcase(
    temp_pf==1 & rose_eligible==1 & eligible_rose_t2, recorded_dttm
  )) |>
  group_by(patient_id, encounter_block) |>
  fill(second_rose_pf, 
       second_rose_sf,
       second_rose_fio2,
       second_rose_peep,
       second_rose_mode,
       t_rose_second,
       .direction = 'updown') |>
  ungroup()
  
  rose_criteria_tmp<- rose_criteria_sf |>
    select(hospitalization_id, encounter_block, second_rose_pf, second_rose_sf, second_rose_fio2, second_rose_peep, second_rose_mode, t_rose_second) |> 
    filter(!is.na(t_rose_second)) |> 
    mutate(criteria_2="sf")
  
  rose_criteria_tmp <- unique(rose_criteria_tmp)
  
  rose_criteria <- rose_criteria |> #now can ID people who meet S/F criteria after 1st s/f to enroll. 
  join(rose_criteria_tmp, how ='left') |>
    mutate(criteria=coalesce(criteria_2, criteria))|>
    select(-criteria_2)
  rm(rose_criteria_tmp)

  #filter to cohort that had a first qualifying s/f without a second in window, want time after the next s/f or p/f, while still in 126h window after intubation
  reassess_pf<- rose_criteria_sf |>
  filter(is.na(t_rose_second) & !is.na(first_rose_sf) & recorded_dttm> t_rose_first & rose_eligible==1) |> 
  #Filter to First 126 Hours After Vent Start (120 hr for MV then 6hr for confirmatory S/F)
  filter(recorded_dttm<=as.POSIXct(vent_episode_start, tz="UTC")+dhours(126)) |>
 # mutate(first_rose_fio2=NA, first_rose_mode=NA, first_rose_peep=NA, first_rose_pf=NA, first_rose_sf=NA, t_rose_first=NA) |>
  mutate(temp_rose_time=fifelse(
    rose_eligible==1 & recorded_dttm<=as.POSIXct(vent_episode_start, tz="UTC")+dhours(120), 1, 0
  )) |>
  group_by(patient_id, encounter_block, temp_rose_time, rose_eligible) |> #By grouping together can define the 1st PF ratios that Meet ROSE criteria, replaces earlier calculation since that s/f didn't have confirmatory low s/f
  arrange(patient_id, encounter_block, recorded_dttm) |>
  mutate(temp_pf=row_number()) |>
  ungroup() |>
  #Identify the PF ratio, FIo2, PEEP, and Mode Where Proseva Criteria First met
  mutate(first_rose_pf_2=fcase(
    temp_pf==1 & rose_eligible==1 & temp_rose_time==1, pf_ratio
  )) |>
  mutate(first_rose_sf_2=fcase(
    temp_pf==1 & rose_eligible==1 & temp_rose_time==1, sf_ratio
  )) |>
  mutate(first_rose_fio2_2=fcase(
    temp_pf==1 & rose_eligible==1 & temp_rose_time==1, fio2_set
  )) |>
  mutate(first_rose_peep_2=fcase(
    temp_pf==1 & rose_eligible==1 & temp_rose_time==1, peep_set
  )) |>
  mutate(first_rose_mode_2=fcase(
    temp_pf==1 & rose_eligible==1 & temp_rose_time==1, mode_category
  )) |>
  mutate(t_rose_first_2=fcase(
    temp_pf==1 & rose_eligible==1 & temp_rose_time==1, recorded_dttm
  )) |>
  group_by(patient_id, encounter_block) |>
  fill(first_rose_pf_2,
       first_rose_sf_2, 
       first_rose_fio2_2,
       first_rose_peep_2,
       first_rose_mode_2,
       t_rose_first_2,
       .direction = 'updown') |>
  ungroup() |>
  collect()

  #group of people with p/f that meets criteria (who didn't originally have s/f meet criteria, need to replace their original s/f timing metrics)
  reassess_pf_quality <- reassess_pf |>
    filter(!is.na(first_rose_pf_2)) |> 
    mutate(criteria_2 = "pf") |>
    select(hospitalization_id, encounter_block, first_rose_pf_2, first_rose_sf_2, first_rose_fio2_2, first_rose_peep_2, first_rose_mode_2, t_rose_first_2, criteria_2) 
  
reassess_pf_quality <- unique(reassess_pf_quality)
  
rose_criteria <- rose_criteria |> #replace old s/f if not eligible with new p/f values that works (later time)
  join(reassess_pf_quality, how ='left') |>
   mutate(first_rose_fio2=fifelse(!is.na(first_rose_pf_2), first_rose_fio2_2, first_rose_fio2), 
          first_rose_pf=fifelse(!is.na(first_rose_pf_2), first_rose_pf_2, first_rose_pf), 
          first_rose_sf=fifelse(!is.na(first_rose_pf_2), NA, first_rose_sf), #if not replacing new pf keep old s/f
          first_rose_peep=fifelse(!is.na(first_rose_pf_2), first_rose_peep_2, first_rose_peep), 
          first_rose_mode=fifelse(!is.na(first_rose_pf_2), first_rose_mode_2, first_rose_mode), 
          t_rose_first=fifelse(!is.na(first_rose_pf_2), t_rose_first_2, t_rose_first), 
          criteria=coalesce(criteria_2, criteria)) |>
  select(-first_rose_fio2_2, -first_rose_pf_2, -first_rose_sf_2, -first_rose_peep_2, -first_rose_mode_2, -t_rose_first_2, -criteria_2) |>
collect()

#check eligibilty based on second s/f in the range. 
  reassess_sf_quality <- reassess_pf |>
    filter(is.na(first_rose_pf_2) & !is.na(first_rose_sf_2)) |> 
    select(hospitalization_id, encounter_block, first_rose_pf_2, first_rose_sf_2, first_rose_fio2_2, first_rose_peep_2, first_rose_mode_2, t_rose_first_2)
  
  reassess_sf_quality<- unique(reassess_sf_quality)
    
  rose_criteria <- rose_criteria |> #replace old s/f if not eligible with new s/f that works (later time), but need to assess that before overwrite
  join(reassess_sf_quality, how ='left') |>
    collect()
    
  #Now for patients qualifying with S/F Repeat For The 2nd Eligible Time - Must be within 1-6 Hours t_rose_first if s/f is what qualifies you
  #This Table is Already Windowed to First 126 Hours of Vent and Ends When patient is extubated/dies/transfers (if before 126 hours)
  rose_criteria_sf2 <- rose_criteria |>
  filter(!is.na(first_rose_sf_2) & is.na(first_rose_pf)) |> #potentially eligible based on 2nd low s/f (first didn't qualify)

  mutate(eligible_rose_t2_2=fifelse(
    recorded_dttm>=as.POSIXct(t_rose_first_2, tz="UTC")+dhours(1) & 
    recorded_dttm<=as.POSIXct(t_rose_first_2, tz="UTC")+dhours(6), 1, 0 # since this is set as 0 when not true, fill updown doesn't overwrite it. 
  )) |>
  group_by(patient_id, encounter_block, eligible_rose_t2_2, rose_eligible) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>
  mutate(temp_pf=row_number()) |>
  ungroup() |>
  mutate(second_rose_pf_2=fcase(
    temp_pf==1 & rose_eligible==1 & eligible_rose_t2_2, pf_ratio
  )) |>
  mutate(second_rose_sf_2=fcase(
    temp_pf==1 & rose_eligible==1 & eligible_rose_t2_2, sf_ratio
  )) |>
  mutate(second_rose_fio2_2=fcase(
    temp_pf==1 & rose_eligible==1 & eligible_rose_t2_2, fio2_set
  )) |>
  mutate(second_rose_peep_2=fcase(
    temp_pf==1 & rose_eligible==1 & eligible_rose_t2_2, peep_set
  )) |>
  mutate(second_rose_mode_2=fcase(
    temp_pf==1 & rose_eligible==1 & eligible_rose_t2_2, mode_category
  )) |>
  mutate(t_rose_second_2=fcase(
    temp_pf==1 & rose_eligible==1 & eligible_rose_t2_2, recorded_dttm
  )) |>
  group_by(patient_id, encounter_block) |>
  fill(second_rose_pf_2, 
       second_rose_sf_2,
       second_rose_fio2_2,
       second_rose_peep_2,
       second_rose_mode_2,
       t_rose_second_2,
       .direction = 'updown') |>
  ungroup()
  
  rose_criteria_tmp<- rose_criteria_sf2 |>
    filter(!is.na(t_rose_second_2)) |>
    mutate(criteria_2="sf") |>
    select(hospitalization_id, encounter_block, second_rose_pf_2, second_rose_sf_2, second_rose_fio2_2, second_rose_peep_2, second_rose_mode_2, t_rose_second_2, criteria_2) 
  
  rose_criteria_tmp<- unique(rose_criteria_tmp)
  
  rose_criteria <- rose_criteria |> #now can ID people who meet S/F criteria after 1st s/f to enroll (the 2nd time, 1st didn't have confirmatory level)
  join(rose_criteria_tmp, how ='left') |>
   mutate(first_rose_fio2=fifelse(!is.na(t_rose_second_2), first_rose_fio2_2, first_rose_fio2), 
          first_rose_pf=fifelse(!is.na(t_rose_second_2), first_rose_pf_2, first_rose_pf), 
          first_rose_sf=fifelse(!is.na(t_rose_second_2), first_rose_sf_2, first_rose_sf), 
          first_rose_peep=fifelse(!is.na(t_rose_second_2), first_rose_peep_2, first_rose_peep), 
          first_rose_mode=fifelse(!is.na(t_rose_second_2), first_rose_mode_2, first_rose_mode), 
          t_rose_first=fifelse(!is.na(t_rose_second_2), t_rose_first_2, t_rose_first),
          second_rose_fio2=fifelse(!is.na(t_rose_second_2), second_rose_fio2_2, second_rose_fio2), 
          second_rose_pf=fifelse(!is.na(t_rose_second_2), second_rose_pf_2, second_rose_pf), 
          second_rose_sf=fifelse(!is.na(t_rose_second_2), second_rose_sf_2, second_rose_sf), #if not replacing new pf keep old s/f
          second_rose_peep=fifelse(!is.na(t_rose_second_2), second_rose_peep_2, second_rose_peep), 
          second_rose_mode=fifelse(!is.na(t_rose_second_2), second_rose_mode_2, second_rose_mode), 
          t_rose_second=fifelse(!is.na(t_rose_second_2), t_rose_second_2, t_rose_second),
          criteria=coalesce(criteria_2, criteria)
          ) |>
  select(-first_rose_fio2_2, -first_rose_pf_2, -first_rose_sf_2, -first_rose_peep_2, -first_rose_mode_2, -t_rose_first_2, -second_rose_fio2_2, -second_rose_pf_2, -second_rose_sf_2, -second_rose_peep_2, -second_rose_mode_2, -t_rose_second_2, -criteria_2) 
  
rm(rose_criteria_tmp)

#among remaining people who may eventually have p/f or s/f eligible, but haven't met criteria yet:    
possible_eligible <- rose_criteria |>
  filter(is.na(criteria) & recorded_dttm>t_rose_first & rose_eligible==1)
possible_eligible <- unique(possible_eligible)

# group that ever has pf criteria met
possible_eligible_pf <- possible_eligible |>
  filter(rose_eligible_pf==1)|>
  group_by(patient_id, encounter_block) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>
  summarise(first_pf_qualify= min(recorded_dttm)) 

# group that ever has sf criteria met
possible_eligible_filtered <- possible_eligible |> #within 6 hours
  group_by(hospitalization_id) |>
  filter(map_lgl(row_number(), function(i) {
    # Calculate diffs from the i-th datetime to all others in the group
    diffs <- (difftime(recorded_dttm[i], recorded_dttm, units = "hours"))
    # Check if any other row satisfies 1 <= diff <= 6
    any(diffs <= -1 & diffs >= -6 & (1:length(diffs)) != i)
  })) |>
  ungroup()

possible_eligible_sf <- possible_eligible_filtered |>
  filter(rose_eligible_sf==1)|>
  group_by(patient_id, encounter_block) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>
  summarise(first_sf_qualify= min(recorded_dttm)) 

#earliest time pf or qualifying sf happen
possible_eligible_either<- possible_eligible_sf |>
  full_join(possible_eligible_pf, by =c('patient_id', 'encounter_block')) |>
  mutate(min_criteria_time = pmin(first_sf_qualify, first_pf_qualify, na.rm=T)) |>
  mutate(criteria_2=case_when(first_pf_qualify==min_criteria_time~ "pf", first_sf_qualify==min_criteria_time~"sf"))
  
#determine the mode/peep, etc values when qualify
possible_eligible <- possible_eligible |>
  left_join(possible_eligible_either)|> 
 mutate(first_rose_fio2_3=fifelse((recorded_dttm==first_sf_qualify & first_sf_qualify==min_criteria_time) | (recorded_dttm==first_pf_qualify & first_pf_qualify==min_criteria_time), fio2_set, NA), 
        first_rose_pf_3=fifelse(recorded_dttm==first_pf_qualify & first_pf_qualify==min_criteria_time, pf_ratio, NA), 
        first_rose_sf_3=fifelse(recorded_dttm==first_sf_qualify & first_sf_qualify==min_criteria_time, sf_ratio, NA),
        first_rose_peep_3=fifelse((recorded_dttm==first_sf_qualify & first_sf_qualify==min_criteria_time) | (recorded_dttm==first_pf_qualify & first_pf_qualify==min_criteria_time), peep_set, NA), 
        first_rose_mode_3=fifelse((recorded_dttm==first_sf_qualify & first_sf_qualify==min_criteria_time) | (recorded_dttm==first_pf_qualify & first_pf_qualify==min_criteria_time), mode_category, NA), 
        t_rose_first_3=fifelse((recorded_dttm==first_sf_qualify & first_sf_qualify==min_criteria_time) | (recorded_dttm==first_pf_qualify & first_pf_qualify==min_criteria_time), recorded_dttm, NA)) |>
  select(encounter_block, hospitalization_id, first_rose_fio2_3, first_rose_pf_3, first_rose_sf_3, first_rose_peep_3, first_rose_mode_3, t_rose_first_3, criteria_2) |>
  filter(!is.na(t_rose_first_3))
  
possible_eligible<- unique(possible_eligible)

rose_criteria <- rose_criteria |> #now can ID people who meet S/F criteria after 1st s/f to enroll (the 2nd time, 1st didn't have confirmatory level)
  join(possible_eligible, how ='left') |>
   mutate(first_rose_fio2=fifelse(!is.na(t_rose_first_3), first_rose_fio2_3, first_rose_fio2), 
          first_rose_pf=fifelse(!is.na(t_rose_first_3), first_rose_pf_3, first_rose_pf), 
          first_rose_sf=fifelse(!is.na(t_rose_first_3), first_rose_sf_3, first_rose_sf), 
          first_rose_peep=fifelse(!is.na(t_rose_first_3), first_rose_peep_3, first_rose_peep), 
          first_rose_mode=fifelse(!is.na(t_rose_first_3), first_rose_mode_3, first_rose_mode), 
          t_rose_first=fifelse(!is.na(t_rose_first_3), t_rose_first_3, t_rose_first),
          criteria= coalesce(criteria_2, criteria),
          first_rose_fio2=fifelse(!is.na(criteria), first_rose_fio2, NA), 
          first_rose_pf=fifelse(!is.na(criteria), first_rose_pf, NA), 
          first_rose_sf=fifelse(!is.na(criteria), first_rose_sf, NA), 
          first_rose_peep=fifelse(!is.na(criteria), first_rose_peep, NA), 
          first_rose_mode=fifelse(!is.na(criteria), first_rose_mode, NA), 
          t_rose_first=fifelse(!is.na(criteria), t_rose_first, NA)
          ) |>
          select(-first_rose_fio2_3, -first_rose_pf_3, -first_rose_sf_3, -first_rose_peep_3, -first_rose_mode_3, -t_rose_first_3, -criteria_2) 
  
rm(possible_eligible)

#NOW Define Who is Eligible by ROSE criteria
rose_criteria_timing <- rose_criteria |>    
  #Select Wanted Variables and Keep First Row for Each Patient and Encounter Block
  select(hospitalization_id, patient_id, encounter_block, first_rose_pf:criteria) 

rose_criteria_timing<- unique(rose_criteria_timing)

```


```{r Define Potentially Eligible Paralytic Episodes - Those Occurring During First Ventilator Episode}
#Filter Medication Tables to Relevant Cohort and Only Times During the First Ventilator Episode
temp_times <- vent_times |> 
  select(patient_id, encounter_block, vent_episode_start, vent_episode_end)

#continuous
paralytics_episodes_all_c <- clif_medication_admin_continuous |>
  mutate(hospitalization_id=as.character(hospitalization_id)) |>
  left_join(cohort_ids) |>
  filter(in_cohort==1) |>
  #Extra Stop Gap To Filter Out Pushes That may Have Made Into Continuous Table
  filter(tolower(med_group) %in% c("paralytics", "paralytic"),
         !tolower(med_dose_unit) %in% c('mg', 'mcg')) |> 
  select(-in_cohort) |>
  left_join(temp_times) |>
  mutate(recorded_dttm=admin_dttm) |>
  left_join(rose_criteria_timing) |>
  collect()
  
paralytics_episodes_c <- paralytics_episodes_all_c |>
  mutate(recorded_dttm=as.POSIXct(recorded_dttm, tz="UTC")) |>
  filter(recorded_dttm>=as.POSIXct(vent_episode_start, tz="UTC") & recorded_dttm<=as.POSIXct(vent_episode_end, tz="UTC"))  #filters to 1st episode of IMV

paralytics_episodes_c<- unique(paralytics_episodes_c)
  
#first time where paralytic dose is not 0 - time to this from meeting criteria, time from intubation
time_to_paralytic_tmp_c <- paralytics_episodes_c |>
  filter(med_dose>0) |> # & mar_action_category=="given") #when finalized. 
  group_by(patient_id, encounter_block) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>
  mutate(paralytic_start_time_c=min(recorded_dttm)) |>
  mutate(ett_to_paralytic_c=difftime(paralytic_start_time_c,vent_episode_start,  units = "hours")) |>
  mutate(criteria_to_paralytic_c=difftime(paralytic_start_time_c,t_rose_first,  units = "hours")) |>
  rename(med_category_c=med_category) |>
  mutate(para_route="continuous") |>
  filter(admin_dttm==paralytic_start_time_c)|>
  filter(row_number()==1) 

time_to_paralytic_c <-time_to_paralytic_tmp_c|>
  select(hospitalization_id, med_category_c, patient_id, encounter_block, first_rose_pf, first_rose_sf, first_rose_fio2, first_rose_peep, first_rose_mode, t_rose_first, criteria, paralytic_start_time_c, ett_to_paralytic_c, criteria_to_paralytic_c, para_route)
time_to_paralytic_c <- unique(time_to_paralytic_c)

#intermittent
paralytics_episodes_all_i <- clif_medication_admin_intermittent |>
  mutate(hospitalization_id=as.character(hospitalization_id)) |>
  left_join(cohort_ids) |>
  filter(in_cohort==1) |>
  filter(tolower(med_group) %in% c("paralytics", "paralytic")) |>
  select(-in_cohort) |>
  left_join(temp_times) |>
  mutate(recorded_dttm=admin_dttm) |>
  left_join(rose_criteria_timing) |>
  filter(med_dose >0) |>
  collect()
  
paralytics_episodes_i <- paralytics_episodes_all_i |>
  mutate(recorded_dttm=as.POSIXct(recorded_dttm, tz="UTC")) |>
  filter(recorded_dttm>=as.POSIXct(vent_episode_start, tz="UTC") & recorded_dttm<=as.POSIXct(vent_episode_end, tz="UTC"))  #filters to 1st episode of IMV

paralytics_episodes_i<- unique(paralytics_episodes_i)
  
#first time where paralytic dose is not 0 - time to this from meeting criteria, time from intubation
time_to_paralytic_tmp_i <- paralytics_episodes_i |>
  filter(med_dose>0) |> # & mar_action_category=="given") #when finalized. 
  group_by(patient_id, encounter_block) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>
  mutate(ett_to_paralytic_i=difftime(recorded_dttm,vent_episode_start,  units = "hours")) |> #row level measure ett to each paralytic
  filter(ett_to_paralytic_i>=1) |>
  mutate(paralytic_start_time_i=min(recorded_dttm)) |>
  mutate(criteria_to_paralytic_i=difftime(paralytic_start_time_i,t_rose_first,  units = "hours")) |>
  mutate(ett_to_paralytic_i=difftime(paralytic_start_time_i,vent_episode_start,  units = "hours")) |> #now get global measure ett to first paralytic
  mutate(para_route_i="intermittent") |>
  mutate(how_many=1) |>
  mutate(intermittent_para=sum(how_many))|>
  rename(med_category_i=med_category) |>
  filter(intermittent_para>0) |>
  filter(admin_dttm==paralytic_start_time_i)|>
  filter(row_number()==1) 

time_to_paralytic_i <- time_to_paralytic_tmp_i |>
  select(hospitalization_id, med_category_i, patient_id, encounter_block, first_rose_pf, first_rose_sf, first_rose_fio2, first_rose_peep, first_rose_mode, t_rose_first, criteria, paralytic_start_time_i, ett_to_paralytic_i, criteria_to_paralytic_i, para_route_i, intermittent_para)
time_to_paralytic_i <- unique(time_to_paralytic_i)

#first time where paralytic dose is not 0 - time to this from meeting criteria, time from intubation -> only counting rose intermittent criteria (>2 pushes)
time_to_paralytic_tmp_i_rose <- paralytics_episodes_i |>
  filter(med_dose>0) |> # & mar_action_category=="given") #when finalized. 
  group_by(patient_id, encounter_block) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>
  mutate(ett_to_paralytic_i_rose=difftime(recorded_dttm,vent_episode_start,  units = "hours")) |> #row level measure ett to each paralytic
  filter(ett_to_paralytic_i_rose>=1) |>
  mutate(paralytic_start_time_i_rose=min(recorded_dttm)) |>
  mutate(criteria_to_paralytic_i_rose=difftime(paralytic_start_time_i_rose,t_rose_first,  units = "hours")) |>
  mutate(ett_to_paralytic_i_rose=difftime(paralytic_start_time_i_rose,vent_episode_start,  units = "hours")) |> #now get global measure ett to first paralytic
  mutate(para_route_i_rose="intermittent") |>
  mutate(how_many=1) |>
  mutate(intermittent_para=sum(how_many))|>
  rename(med_category_i=med_category) |>
  filter(intermittent_para>2) |>
  filter(admin_dttm==paralytic_start_time_i_rose) |>
  filter(row_number()==1) 
  
  time_to_paralytic_i_rose <- time_to_paralytic_tmp_i_rose |>
  select(hospitalization_id, med_category_i, patient_id, encounter_block, first_rose_pf, first_rose_sf, first_rose_fio2, first_rose_peep, first_rose_mode, t_rose_first, criteria, paralytic_start_time_i_rose, ett_to_paralytic_i_rose, criteria_to_paralytic_i_rose, para_route_i_rose, intermittent_para)
time_to_paralytic_i_rose <- unique(time_to_paralytic_i_rose)

```



```{r Now Incorporate with ROSE Criteria Into Final ROSE-paralytic Criteria for This Cohort}
#For Those Who Meet ROSE Criteria as Outlined Above They are ROSE Eligible

#Get vent settings at time start on paralytics_intermittent
paralytic_start_i <- time_to_paralytic_i |>
  mutate(recorded_dttm =paralytic_start_time_i) |>
  full_join(vent_data) |>
  mutate(ratio=coalesce(as.numeric(pf_ratio), as.numeric(sf_ratio))) |>
  group_by(patient_id, encounter_block) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>
  mutate(ratio_cf=ratio) |>
  fill(ratio_cf, .direction= "down") |>
  filter(recorded_dttm == paralytic_start_time_i) |>
  select(hospitalization_id:recorded_dttm, ratio_cf) |>
  select(-recorded_dttm) |>
  rename(ratio_at_paralytics_i = ratio_cf)

#Get vent settings at time start on paralytics_intermittent
paralytic_start_i_rose <- time_to_paralytic_i_rose |>
  mutate(recorded_dttm =paralytic_start_time_i_rose) |>
  full_join(vent_data) |>
  mutate(ratio=coalesce(as.numeric(pf_ratio), as.numeric(sf_ratio))) |>
  group_by(patient_id, encounter_block) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>
  mutate(ratio_cf=ratio) |>
  fill(ratio_cf, .direction= "down") |>
  filter(recorded_dttm == paralytic_start_time_i_rose) |>
  select(hospitalization_id:recorded_dttm, ratio_cf) |>
  select(-recorded_dttm) |>
  rename(ratio_at_paralytics_i_rose = ratio_cf)

#Get vent settings at time start on paralytics_continuous
paralytic_start_c <- time_to_paralytic_c |>
  mutate(recorded_dttm =paralytic_start_time_c) |>
  full_join(vent_data) |>
  mutate(ratio=coalesce(as.numeric(pf_ratio), as.numeric(sf_ratio))) |>
  group_by(patient_id, encounter_block) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>
  mutate(ratio_cf=ratio) |>
  fill(ratio_cf, .direction= "down") |>
  filter(recorded_dttm == paralytic_start_time_c) |>
  select(hospitalization_id:recorded_dttm, ratio_cf) |>
  select(-recorded_dttm) |>
  rename(ratio_at_paralytics_c = ratio_cf)

#data among all patients who start paralytics during admission. 
paralytic_start_all <- paralytic_start_c |>
  full_join(paralytic_start_i)

#data among patients who start rose_qualifying paralytics (bolus >2) during admission. 
paralytic_start_all_rose <- paralytic_start_c |>
  full_join(paralytic_start_i_rose)

#data among patients who meet ROSE criteria, including only para >2, cannot have been on continuous paralytics >3h prior to meeting criteria or received >2 pushes prior
final_cohort_rose_rose<- rose_criteria_timing |>
  filter(!is.na(criteria)) |>
  left_join(paralytic_start_all_rose) |>
  filter(is.na(criteria_to_paralytic_c) | criteria_to_paralytic_c>-3) |>
  filter(is.na(criteria_to_paralytic_i_rose) | criteria_to_paralytic_i_rose>0 | intermittent_para <3) |>
  mutate(any_paralytic_48 = fifelse((!is.na(criteria_to_paralytic_c) & criteria_to_paralytic_c<48)  | (!is.na(criteria_to_paralytic_i_rose) & criteria_to_paralytic_i_rose <48), 1, 0),
         any_paralytic_12 = fifelse((!is.na(criteria_to_paralytic_c) & criteria_to_paralytic_c<12)  | (!is.na(criteria_to_paralytic_i_rose) & criteria_to_paralytic_i_rose <12), 1, 0), 
         any_paralytic_24 = fifelse((!is.na(criteria_to_paralytic_c) & criteria_to_paralytic_c<24)  | (!is.na(criteria_to_paralytic_i_rose) & criteria_to_paralytic_i_rose <24), 1, 0), 
         any_paralytic_72 = fifelse((!is.na(criteria_to_paralytic_c) & criteria_to_paralytic_c<72)  | (!is.na(criteria_to_paralytic_i_rose) & criteria_to_paralytic_i_rose <72), 1, 0), 
         any_paralytic_ever = fifelse((!is.na(criteria_to_paralytic_c))  | (!is.na(criteria_to_paralytic_i_rose)), 1, 0),
         first_rose_pf_all= coalesce(first_rose_pf, first_rose_sf)) 

cat('This yields an eligible ROSE cohort of', length(unique(final_cohort_rose_rose$hospitalization_id)), 'hospitalizations, of which',
              sum(final_cohort_rose_rose$any_paralytic_48), 'were started on paralytics in 48 hours, ',
    sum(final_cohort_rose_rose$any_paralytic_12), 'were started on paralytics in 12 hours, ',
    sum(final_cohort_rose_rose$any_paralytic_24), 'were started on paralytics in 24 hours, ',
    sum(final_cohort_rose_rose$any_paralytic_72), 'were started on paralytics in 72 hours, and ',    
    sum(final_cohort_rose_rose$any_paralytic_ever), 'were ever started on paralytics, all defined by continuous dosing or at least 3 pushes \n')

```

```{r Define Proning Episodes for covariate inclusion - Those Occurring During First Ventilator Episode}
#Filter Position Table to Relevant Cohort and Only Times During the First Ventilator Episode
temp_times <- vent_times |> 
  select(patient_id, encounter_block, vent_episode_start, vent_episode_end)

prone_episodes_all <- clif_position |>
  mutate(hospitalization_id=as.character(hospitalization_id)) |>
  left_join(cohort_ids) |> #NOTE: clif_labs will now include patient_id and encounter_block
  filter(in_cohort==1) |>
  filter(!is.na(position_category)) |>
  select(-in_cohort) |>
  left_join(temp_times) |>
  collect()

#output position data for categories >= 10 times while prone
position_output<- data.frame(table(prone_episodes_all$position_category, prone_episodes_all$position_name, useNA = "always"))
position_output<- position_output %>% filter(Freq>10) # if happening less than 10 times, don't output
position_output<- position_output %>% rename(position_category=Var1) 
position_output<- position_output %>% rename(position_name=Var2)
position_output<- position_output %>% filter(position_category=="prone") 
position_output$semi_prone<- grepl("semi", position_output$position_name, ignore.case = TRUE)  
if(any(position_output$semi_prone==TRUE)) warning("QC: You may have semi-prone data mapped to the proned position_category. Patients in a semi-proned position should not be considered prone unless there is an additional prone documentation at the same time. Please review your position-name to position_category mapping to determine how semi-prone data is mapped to position_category") 
#write_csv(position_output, paste0(project_location, "/project_output/",site, "_position_output.csv")) 
  
prone_episodes <- prone_episodes_all |>
  mutate(recorded_dttm=as.POSIXct(recorded_dttm, tz="UTC")) |>
  filter(recorded_dttm>=as.POSIXct(vent_episode_start, tz="UTC") & recorded_dttm<=as.POSIXct(vent_episode_end, tz="UTC")) |>
  #Filter to Rows Where 'position_category' changes --> This will allow some institutions to select 'all positions' and some to only keep rows where position changes
  group_by(patient_id, encounter_block) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>
  mutate(keep=fcase(
    row_number()==1, 1,
    row_number()==n(), 1,
    position_category!=lag(position_category), 1)) |>
  mutate(keep=fifelse(
    #IF Both Prone and Supine Are Recorded at the Same Time Will Exclude
    position_category!=lag(position_category) & recorded_dttm==lag(recorded_dttm), 0, keep)) |>
  ungroup() |>
  filter(keep==1) |>
  #Deal with Last Row if It is NOT a new Category
  group_by(patient_id, encounter_block) |>
  mutate(keep=fifelse(
    row_number()==n() & 
      position_category==lag(position_category) &
      n()>1, 0, keep
  )) |>
  #Calculate the Time in Hours to Next Observation - For the Second to Last Row
  mutate(time_to_lastrow=fcase(
    lead(keep)==0,
    as.duration(lead(recorded_dttm)-recorded_dttm)/dhours(1))) |>
  #This Keeps Track of Whether the Last Observation in a Position_category SHould Use the Vent-end or time to last row to determine duration
  mutate(use_time_to_lastrow=fcase(
    lead(row_number())==n() & lead(keep)==0, 1,
    row_number()==n() & keep==1, 0,
    default = 0
  )) |>
  filter(keep==1) |>
  #Now Define # of Prone Episodes (during First Ventilator Episode)
  group_by(patient_id, encounter_block, position_category) |>
  mutate(temp_episode_num=row_number()) |>
  ungroup() |>
  group_by(patient_id, encounter_block) |>
  mutate(prone_episode_num=fcase(
    position_category=='prone', temp_episode_num)) |>
  ungroup() |>
  #Define Prone Position Duration - Time to Next Row OR if the Prone Episode is Last Row it is Time to Vent End
  group_by(patient_id, encounter_block) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>
  mutate(prone_episode_hours=fcase(
    position_category=='prone' & row_number()!=n(), as.duration(lead(recorded_dttm)-recorded_dttm)/dhours(1),
    position_category=='prone' & row_number()==n() & use_time_to_lastrow==0, as.duration(vent_episode_end-recorded_dttm)/dhours(1),
    position_category=='prone' & row_number()==n() & use_time_to_lastrow==1, time_to_lastrow,
    position_category=='prone' & row_number()==1 & use_time_to_lastrow==0, as.duration(vent_episode_end-recorded_dttm)/dhours(1),
    position_category=='prone' & row_number()==1 & use_time_to_lastrow==1, time_to_lastrow
  )) |>
  filter(position_category=='prone') |>
  mutate(prone_episodes=max(prone_episode_num)) |>
  mutate(first_prone_episode_hours=fcase(
    prone_episode_num==1, prone_episode_hours
  )) |>
  mutate(first_prone_time=fcase(
    prone_episode_num==1, as.POSIXct(recorded_dttm, tz="UTC")
  )) |>
  mutate(median_pt_prone_duration=median(prone_episode_hours)) |>
  mutate(mean_pt_prone_duration=mean(prone_episode_hours)) |>
  filter(row_number()==1) |>
  ungroup() |>
  select(patient_id, encounter_block, prone_episodes:mean_pt_prone_duration)
rm(temp_times)
```


```{r Add in Covariate, Vent Data, and Patient Outcomes}
#Generate a Table of ALL HOspitalization IDs (here this Deals with the 'Linked' Encounters)
temp <- cohort_ids |> select(patient_id, encounter_block, in_cohort)
cohort_hospitalization_ids <- clif_hospitalization |>
  mutate(hospitalization_id=as.character(hospitalization_id)) |>
  left_join(temp) |>
  filter(in_cohort==1) |>
  select(patient_id, hospitalization_id, encounter_block, in_cohort) |>
  distinct() |>
  collect()
rm(temp)

#Get Needed Variables from Hospitalization Tables
#Age, Discharge Category, Final Admission Dttm, Final Discharge Dttm
hospitalization_vars <- clif_hospitalization |>
  mutate(hospitalization_id=as.character(hospitalization_id)) |>
  left_join(cohort_ids) |>
  filter(in_cohort==1) |>
  select(patient_id, encounter_block, age_at_admission, final_admission_dttm, final_discharge_dttm, final_discharge_category) |>
  collect() |>
  mutate(in_hosp_death=fifelse(
    tolower(final_discharge_category)=='expired', 1, 0
  )) |>
  mutate(death_or_hospice=fifelse(
    tolower(final_discharge_category) %in% c('expired', 'hospice'), 1, 0
  )) 

#Will Use Cohort_ids, but Also a Table of Vent Times and t_enrollment
temp <- hospitalization_vars |> select(patient_id, encounter_block, final_admission_dttm, final_discharge_dttm)
temp<- unique(temp)
cohort_times <- final_cohort_rose_rose |>
 # select(patient_id, encounter_block, t_rose_first, vent_episode_start, vent_episode_end) |>
  left_join(temp) 
rm(temp)

#What Hospital is the Patient at When t_enrollment Occurs
#Was the Patient in a Procedural Area In the Week Prior to t_enrollment?
hospital_location <- clif_adt |>
  mutate(hospitalization_id=as.character(hospitalization_id)) |>
  left_join(cohort_hospitalization_ids) |>
  filter(in_cohort==1) |>
  left_join(cohort_times) |>
  arrange(patient_id, encounter_block, in_dttm) |>
  collect() |>
  mutate(
    enrollment_icu=fifelse(
    as.POSIXct(t_rose_first, tz="UTC")>=as.POSIXct(in_dttm, tz="UTC") &
      as.POSIXct(t_rose_first, tz="UTC")<=as.POSIXct(out_dttm, tz="UTC"), 1,0)) |>
  
  #If the Patient Meets Criteria in an ED or Procedural Area Take the First Non Procedural Location After This Row
  group_by(patient_id, encounter_block) |>
  arrange(patient_id, encounter_block, in_dttm) |>
  #Number the Rows
  mutate(location_count=row_number()) |>
  #Identify Location Category of the Current 'enrollment_icu'
  mutate(temp_category=fcase(
    enrollment_icu==1, location_category
  )) |>
  mutate(temp_count=fcase(
    enrollment_icu==1, location_count
  )) |>
  fill(temp_category, temp_count, .direction = 'updown') |>
  
  #Only Number the Locations that Come After the Number of Location Where Enrollment ICU Met
  #By Making Those At or Before T-Enrollment Allows us to Take Minimum Row Number to Get the Next
  mutate(location_count=fifelse(
    location_count<=temp_count | is.na(temp_count), 99999, location_count
  )) |>
  
  #Make Ward, L&D, stepdown, ED or Procedural Areas NA in terms of Count
  mutate(location_count=fifelse(
    tolower(location_category) %in% c('ed', 'procedural', 'ward', 'l&d', 'stepdown'), NA_real_, location_count
  )) |>
  #If the Patient t_enrollment was in ward, L&D, stepdown, ed or procedural area, take the first icu area after this
 mutate(enrollment_icu=fifelse(
    temp_category %in% c('procedural', 'ed', 'ward', 'l&d', 'stepdown') & 
      location_count==min(location_count, na.rm=TRUE), 1, enrollment_icu
  )) |>
  #If the Patient Meets Criteria in an Operative Area Take the First Non Procedural Location Before or After
  mutate(or_before_enrollment=fifelse(
    tolower(location_category) =='procedural' & 
      as.POSIXct(in_dttm, tz="UTC")>=as.POSIXct(t_rose_first, tz="UTC")-ddays(2) &
      as.POSIXct(in_dttm, tz="UTC")<=as.POSIXct(t_rose_first, tz="UTC"), 1, 0
  )) |>
  group_by(patient_id, encounter_block) |>
  mutate(or_before_enrollment=max(or_before_enrollment, na.rm = TRUE)) |>
  mutate(keep=fcase(
    enrollment_icu==1, 1, 
    max(enrollment_icu, na.rm=TRUE)==0 & row_number()==1, 1
  )) |>
  filter(keep==1) |>
  ungroup() |>
  select(patient_id, encounter_block, location_category, location_name, or_before_enrollment, hospital_id, location_type) |>
  rename(enrollment_location_category = location_category,
         enrollment_location_name = location_name,
         enrollment_location_type = location_type) |>
  mutate(enrollment_location_type= fifelse(!is.na(enrollment_location_type) | enrollment_location_type!='NA', enrollment_location_type, "Other")) |>
  distinct()

demos <- clif_patient |>
  filter(patient_id %in% cohort_ids$patient_id) |>
  collect()|>
  group_by(patient_id) |>
  filter(row_number()==n()) |>
  select(patient_id, race_category, ethnicity_category, sex_category) |>
  ungroup()

code_status <- clif_code_status |>
  filter(patient_id %in% cohort_ids$patient_id) |>
  collect()|>
  group_by(patient_id) |>
  mutate(code_status_category=case_when(code_status_category=="DNR" | code_status_category=="DNAR" ~"No resuscitation, okay with intubation", code_status_category=="DNR/DNI" | code_status_category=="DNAR/DNI"~"No resuscitation, no intubation", code_status_category=="DNI_only"~"Okay with resuscitation, except no intubation", code_status_category=="Full" | code_status_category=="Presume Full"~"Full", code_status_category=="Other"~"Other", code_status_category=="UDNR"~"UDNR", code_status_category=="AND"~"Allow natural death")) |>
  join(cohort_times, how = 'left') |>
  select(patient_id, start_dttm, code_status_category, code_status_name, t_rose_first) |>
  ungroup()
  
code_status_rose <- code_status |>
  filter(!is.na(start_dttm)) |>
  filter(as.POSIXct(start_dttm, tz="UTC") <=as.POSIXct(t_rose_first, tz="UTC")) |>
  group_by(patient_id) |>
  mutate(time_diff = abs(difftime(start_dttm, t_rose_first))) |>
  filter(time_diff == min(time_diff)) |>
  select(-time_diff, -t_rose_first)

code_status_rose <- unique(code_status_rose) #most recently updated code status info at time of meeting rose criteria, if missing then presume full. 

#Calculate BMI
bmi <- clif_vitals |>
  filter(vital_category %in% c('weight_kg', 'height_cm')) |>
  filter(hospitalization_id %in% cohort_hospitalization_ids$hospitalization_id) |>
  #Filter Outliers
  filter((vital_category=='height_cm' & vital_value>=76.2 & vital_value<=244) |
         (vital_category=='weight_kg' & vital_value>=20 & vital_value<=1100)) |>
  collect() |>
  join(cohort_hospitalization_ids, how = 'left') |>
  join(cohort_times, how = 'left') |>
  #Pick Height and Weight Closest to Enrollment
  #First Calculate Time Difference
  mutate(time_diff=as.duration(as.POSIXct(t_rose_first)-as.POSIXct(recorded_dttm))/dhours(1)) |>
  #Define if Before or After t_entrollment
  mutate(before_enrollment=fifelse(time_diff>=0, 1, 0)) |>
  group_by(patient_id, encounter_block, before_enrollment, vital_category) |> #With this Grouping You keep Closest Before and After t_entrollment
  mutate(keep=fifelse(
    abs(time_diff)==min(abs(time_diff)), 1, 0
  )) |>
  filter(keep==1) |>
  #Now Select Height/Weight (Preferably This is Prior to Enrollment)
  group_by(patient_id, encounter_block) |>
  mutate(study_height_cm=fcase(
    keep==1 & before_enrollment==1 & vital_category=='height_cm', vital_value
  )) |>
  mutate(study_weight_kg=fcase(
      keep==1 & before_enrollment==1 & vital_category=='weight_kg', vital_value
  )) |>
  fill(study_height_cm, study_weight_kg, .direction = 'downup') |>
  #IF missing Can Use First Value After Enrollment
  mutate(study_height_cm=fifelse(
    is.na(study_height_cm) & keep==1 & 
      before_enrollment==0 & vital_category=='height_cm', 
    vital_value, study_height_cm
  )) |>
  mutate(study_weight_kg=fifelse(
     is.na(study_weight_kg) &  keep==1 & before_enrollment==0 & vital_category=='weight_kg', 
     vital_value, study_weight_kg
  )) |>
  fill(study_height_cm, study_weight_kg, .direction = 'downup') |>
  filter(row_number()==1) |>
  ungroup() |>
  #Calculate BMI
  mutate(bmi=study_weight_kg/((study_height_cm/100)^2)) |>
  select(patient_id, encounter_block, study_height_cm, study_weight_kg, bmi)

# #Lowest PF Between Time of Intubation and t_enrollment
temp_times <- cohort_times |>
  select(patient_id, encounter_block, t_rose_first)
# min_pf <- vent_data |>
#   filter(!is.na(pf_ratio)) |>
#   join(temp_times, how = 'left') |>
#   filter(as.POSIXct(recorded_dttm, tz="UTC")>=as.POSIXct(vent_episode_start, tz="UTC") &
#            as.POSIXct(recorded_dttm, tz="UTC")<=as.POSIXct(t_rose_first, tz="UTC")) |>
#   group_by(patient_id, encounter_block) |>
#   mutate(min_pf_ratio=min(pf_ratio, na.rm = TRUE)) |>
#   filter(row_number()==1) |>
#   ungroup() |>
#   select(patient_id, encounter_block, min_pf_ratio)

#Set tidal volume at time of t_enrollment -> will ultimately use weight calculated above to determine TV in cc/kg. 
set_tv <- vent_data |>
  filter(!is.na(tidal_volume_set)) |>
  join(temp_times, how = 'left') |>
  filter(as.POSIXct(recorded_dttm, tz="UTC")>=as.POSIXct(vent_episode_start, tz="UTC") &
           as.POSIXct(recorded_dttm, tz="UTC")<=as.POSIXct(t_rose_first, tz="UTC")) |>
  group_by(patient_id, encounter_block) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>
  mutate(set_tv_enrollment=flast(tidal_volume_set, na.rm = TRUE)) |>
  ungroup() |>
  select(patient_id, encounter_block, set_tv_enrollment) 
set_tv <- unique(set_tv)

#Highest minute ventilation observed in 12 hours prior to time of t_enrollment 
mv_obs <- vent_data |>
  filter(!is.na(minute_vent_obs)) |>
  join(temp_times, how = 'left') |>
  filter(as.POSIXct(recorded_dttm, tz="UTC")>=as.POSIXct(vent_episode_start, tz="UTC") &
           as.POSIXct(recorded_dttm)>=as.POSIXct(t_rose_first)-dhours(12) & 
           as.POSIXct(recorded_dttm)<=as.POSIXct(t_rose_first)) |>
  group_by(patient_id, encounter_block) |>
  mutate(mv_obs_max=max(minute_vent_obs, na.rm = TRUE)) |>
  ungroup() |>
  select(patient_id, encounter_block, mv_obs_max) 
mv_obs <- unique(mv_obs)

#Highest plateau pressure observed in 24 hours prior to time of t_enrollment 
plat_tmp <- vent_data |>
  join(temp_times, how = 'left') |>
  filter(as.POSIXct(recorded_dttm, tz="UTC")>=as.POSIXct(vent_episode_start, tz="UTC") &
           as.POSIXct(recorded_dttm)>=as.POSIXct(t_rose_first)-dhours(24) & 
           as.POSIXct(recorded_dttm)<=as.POSIXct(t_rose_first)) |>
  mutate(plateau_pressure_obs = case_when(plateau_pressure_obs>peep_set~plateau_pressure_obs)) |> 
  collect()

#If no plat pressure then use observed peak pressure for now - if large % plat pressure missing across consortium, will ultimately use MICE to impute
plat <- plat_tmp |>  
  mutate(tidal_volume = coalesce(tidal_volume_set, tidal_volume_obs),
         compliance = tidal_volume / (plateau_pressure_obs - peep_set), 
         peak_inspiratory_pressure_obs = case_when(peak_inspiratory_pressure_obs>peep_set~peak_inspiratory_pressure_obs),
         plat_estimate = coalesce(plateau_pressure_obs, peak_inspiratory_pressure_obs), 
        compliance_estimate =  tidal_volume / (plat_estimate - peep_set)) |>
  group_by(patient_id, encounter_block) |>
  mutate(plat_max=max(plateau_pressure_obs, na.rm = TRUE), 
         plat_estimate_max=max(plat_estimate, na.rm = TRUE), 
     compliance_min=min(compliance, na.rm = TRUE), 
     compliance_estimate_min=min(compliance_estimate, na.rm = TRUE)) |>
     ungroup() |>
  select(patient_id, encounter_block, plat_max, compliance_min, plat_estimate_max, compliance_estimate_min)

plat <- unique(plat) |>
  mutate(plat_max=fifelse(plat_max >-Inf, plat_max, NaN), 
         plat_estimate_max =fifelse(plat_estimate_max >-Inf, plat_estimate_max, NaN), 
         compliance_min=fifelse(compliance_min <Inf, compliance_min, NaN), 
         compliance_estimate_min=fifelse(compliance_estimate_min <Inf, compliance_estimate_min, NaN),
         measured_plateau=fifelse(!is.na(plat_max), 1, 0))
  
# compliance <- plat_tmp |>
#   join(plat, how='left') |>
#   group_by(patient_id, encounter_block) |>
#   mutate(compliance=tidal_volume_set / (plat_estimate_max - peep_set)) |>
#   mutate(compliance_min = min(compliance, na.rm=TRUE)) |>
#   ungroup() |>
#   select(patient_id, encounter_block, compliance_min, plat_estimate_max, measured_plateau, peep_set, tidal_volume_set) |>
#   filter(compliance_min <Inf) 
# compliance <- unique(compliance)
  
#Biggest difference between set and observed RR in 12 hours prior to time of t_enrollment 
set_rr <- vent_data |>
  filter(!is.na(resp_rate_obs)) |>
  join(temp_times, how = 'left') |>
  filter(as.POSIXct(recorded_dttm, tz="UTC")>=as.POSIXct(vent_episode_start, tz="UTC") &
           as.POSIXct(recorded_dttm)>=as.POSIXct(t_rose_first)-dhours(12) & 
           as.POSIXct(recorded_dttm)<=as.POSIXct(t_rose_first)) |>
  filter(resp_rate_obs<=90) |>
  mutate(rr_diff=resp_rate_obs-resp_rate_set) |>
  group_by(patient_id, encounter_block) |>
  arrange(patient_id, encounter_block, recorded_dttm) |>
  mutate(rr_diff_max=max(rr_diff, na.rm = TRUE)) |>
  filter(rr_diff_max >-Inf) |>
  ungroup() |>
  select(patient_id, encounter_block, rr_diff_max) 
set_rr <- unique(set_rr)
rm(temp_times)

#Calculate Norepinephrine Equivalent
pressor_data <- clif_medication_admin_continuous |>
  filter(hospitalization_id %in% cohort_hospitalization_ids$hospitalization_id) |>
  left_join(cohort_hospitalization_ids) |>
  filter(in_cohort==1) |>
  filter(med_group=='vasoactives') |>
  filter(!is.na(med_dose)) |>
  left_join(cohort_times) |>
  left_join(bmi) |> #For Weights
  arrange(patient_id, encounter_block, admin_dttm) |>
  collect() |>
  mutate(med_dose=as.character(med_dose)) |>
  mutate(med_dose = as.numeric(parse_number(med_dose))) |>
  filter(as.POSIXct(admin_dttm)>=as.POSIXct(t_rose_first)-dhours(24) & 
           as.POSIXct(admin_dttm)<=as.POSIXct(t_rose_first)) |>
  collect()

  pressor_units <- as.data.frame(table(pressor_data$med_dose_unit, useNA = "always"))
  write_csv(pressor_units, paste0(project_location, '/project_output/aggregate_pressor_units.csv'))

  #Define if a Pressor Needs Weight Based Dosing
pressor_data <- pressor_data |>
  mutate(med_dose_unit=tolower(med_dose_unit)) |>
  mutate(needs_wt_based=fifelse((med_dose_unit=="mcg/min" | med_dose_unit=="mg/min" | med_dose_unit=="ng/min" ), 1, 0)) |>
  #Filter if Given in Bolus Dosing as this is code dosing (mg, mcg, units), or ml/hr as this is rate not dose and needs concentration conversion in ETL
  filter(!(med_dose_unit %in% c('mg', 'mcg', 'ml/hr', 'units', 'milli-units/kg/hr'))) |>
  mutate(wt_dose=fcase(
    needs_wt_based==0, med_dose,
    needs_wt_based==1, med_dose/study_weight_kg)) |>
  group_by(patient_id, encounter_block) |>
  mutate(norepi_dose=fcase(med_category=="norepinephrine" , wt_dose
  )) |>
  fill(norepi_dose, .direction ="down") |>
  mutate(norepi_on=fcase(
    norepi_dose > 0 , 1,
    (is.na(norepi_dose) | norepi_dose==0) , 0 )) |>
  mutate(norepi_dose=fifelse(is.na(norepi_dose), 0, norepi_dose)) |> #Need to Have Dose be Zero if No Dose Got Carried Forward
  mutate(epi_dose=fcase(
    med_category=="epinephrine" , wt_dose
  )) |>
  fill(epi_dose, .direction = "down") |>
  mutate(epi_on=fcase(
    epi_dose>0 , 1,
    (is.na(epi_dose) | epi_dose==0) , 0 )) |>
  mutate(epi_dose=fifelse(is.na(epi_dose), 0, epi_dose)) |>
  mutate(phenyl_dose=fcase(
    med_category=="phenylephrine" , wt_dose
  )) |>
  fill(phenyl_dose, .direction = "down") |>
  mutate(phenyl_on=fcase(
    phenyl_dose>0 , 1,
    (is.na(phenyl_dose) | phenyl_dose==0) , 0 )) |>
  mutate(phenyl_dose=fifelse(is.na(phenyl_dose), 0, phenyl_dose)) |>
  mutate(vaso_dose=fcase(
    med_category=="vasopressin" , wt_dose
  )) |>
  fill(vaso_dose, .direction = "down") |>
  mutate(vaso_on=fcase(
    vaso_dose>0 , 1,
    (is.na(vaso_dose) | vaso_dose==0) , 0 )) |>
  mutate(vaso_dose=fifelse(is.na(vaso_dose), 0, vaso_dose)) |>
  mutate(angiotensin_dose=fcase(
    med_category=="angiotensin" , wt_dose
  )) |>
  fill(angiotensin_dose, .direction = "down") |>
  mutate(angiotensin_on=fcase(
    angiotensin_dose>0 , 1,
    (is.na(angiotensin_dose) | angiotensin_dose==0) , 0 )) |>
  mutate(angiotensin_dose=fifelse(is.na(angiotensin_dose), 0, angiotensin_dose)) |>
  mutate(dopa_dose=fcase(
    med_category=="dopamine" , wt_dose
  )) |>
  fill(dopa_dose, .direction = "down") |>
  mutate(dopa_on=fcase(
    dopa_dose>0 , 1,
    (is.na(dopa_dose) | dopa_dose==0) , 0 )) |>
  mutate(dopa_dose=fifelse(is.na(dopa_dose), 0, dopa_dose)) |>
  mutate(dobut_dose=fcase(
    med_category=="dobutamine" , wt_dose
  )) |>
  fill(dobut_dose, .direction = "down") |>
  mutate(milrinone_dose=fcase(
    med_category=="milrinone" , wt_dose
  )) |>
  fill(milrinone_dose, .direction = "down") |>
  mutate(milrinone_on=fcase(
    dopa_dose>0 , 1,
    (is.na(milrinone_dose) | milrinone_dose==0) , 0 )) |>
  mutate(isoproterenol_dose=fcase(
    med_category=="isoproterenol" , wt_dose
  )) |>
  fill(isoproterenol_dose, .direction = "down") |>
  mutate(isoproterenol_on=fcase(
    isoproterenol_dose>0 , 1,
    (is.na(isoproterenol_dose) |isoproterenol_dose==0) , 0 )) |>
  ungroup() |>
  #See Kotani et al for Norepi dose equivalents for Epi, Phenyl, Vaso, Dopa, Angiotensin), vaso is not weight based. 
  mutate(pressor_on=(norepi_on + epi_on + phenyl_on + vaso_on + dopa_on + angiotensin_on)) |> 
  mutate(norepi_equivalent=norepi_dose + epi_dose+ vaso_dose*2.5+ angiotensin_dose*0.0025+ dopa_dose/100+ phenyl_dose*0.06) |>
  mutate(sofa_pressor=case_when(dopa_dose>15 | epi_dose>0.1 | norepi_dose>0.1 ~4, dopa_dose>5 | (epi_dose>0 & epi_dose <=0.1) | (norepi_dose>0 & norepi_dose<=0.1) ~3, (dopa_dose>0 & dopa_dose<=5) | dobut_dose>0~2 , pressor_on==0~0)) |>
  mutate(sofa_pressor=case_when(is.na(sofa_pressor)~0, is.na(sofa_pressor)==F~sofa_pressor)) |>
  collect()

#Select max sofa pressor in 24h period
sofa_pressors <- pressor_data |>
  group_by(patient_id, encounter_block) |>
  mutate(max_sofa_pressor=max(sofa_pressor, na.rm = TRUE)) |>
  filter(row_number()==1) |>
  select(patient_id, encounter_block, max_sofa_pressor) |> #, norepi_dose, epi_dose, vaso_dose, angiotensin_dose, dopa_dose, phenyl_dose) |>
  ungroup()

#Now Select Max NEE In this 24 Hour Period 
norepi_equivalent <- pressor_data |>
  filter(as.POSIXct(admin_dttm)>=as.POSIXct(t_rose_first)-dhours(24) & 
           as.POSIXct(admin_dttm)<=as.POSIXct(t_rose_first)) |>
  group_by(patient_id, encounter_block) |>
  mutate(max_norepi_equivalent=max(norepi_equivalent, na.rm = TRUE)) |>
  filter(row_number()==1) |>
  mutate(nee_pressor_dose=case_when(max_norepi_equivalent==0~0, max_norepi_equivalent>0 & max_norepi_equivalent<=0.1~1, max_norepi_equivalent>.1~2)) |>
  select(patient_id, encounter_block, nee_pressor_dose) |> #, norepi_dose, epi_dose, vaso_dose, angiotensin_dose, dopa_dose, phenyl_dose) |>
  ungroup()

# Calculate lowest GCS for sofa in 24h prior to enrollment
sofa_gcs <- clif_patient_assessments |>
  filter(assessment_category == "gcs_total") |> 
  filter(hospitalization_id %in% cohort_hospitalization_ids$hospitalization_id) |> 
  #Filter Outliers  
  filter(numerical_value<=15 & numerical_value>=3) |>
  collect() |>
  join(cohort_hospitalization_ids, how = 'left') |>
  join(cohort_times, how = 'left') |>
  #Pick in 24h prior to enrollment
  filter(as.POSIXct(recorded_dttm)>=as.POSIXct(t_rose_first)-dhours(24) & 
           as.POSIXct(recorded_dttm)<=as.POSIXct(t_rose_first)) |>
  mutate(sofa_gcs=case_when(numerical_value==15~0,  numerical_value==13 | numerical_value==14~1, numerical_value>=10 & numerical_value<=12~2, numerical_value>=6 & numerical_value<=9~3, numerical_value<6~4)) |> 
  group_by(patient_id, encounter_block) |>
  mutate(max_sofa_gcs=max(sofa_gcs, na.rm = TRUE)) |>
  filter(row_number()==1) |>
  select(patient_id, encounter_block, max_sofa_gcs) |> 
  ungroup()

# Calculate lowest RASS for sofa in 24h prior to enrollment
sofa_rass <- clif_patient_assessments |> 
  filter(assessment_category == "RASS") |> 
  filter(hospitalization_id %in% cohort_hospitalization_ids$hospitalization_id) |> 
  #Filter Outliers  
  filter(numerical_value<=4 & numerical_value>-6) |>
  collect() |>
  join(cohort_hospitalization_ids, how = 'left') |>
  join(cohort_times, how = 'left') |>
  join(vent_times, how = 'left') |>
  collect()

#Add RASS value -5 at time of vent start
rass_tmp <- vent_times |>
  select(patient_id, encounter_block, vent_episode_start) |>
  mutate(recorded_dttm = vent_episode_start, 
         numerical_value = -5, 
         assessment_category = "RASS")
rass_tmp<- unique(rass_tmp)

sofa_rass <- bind_rows(sofa_rass, rass_tmp) |>
  group_by(patient_id, encounter_block) |>
  arrange(patient_id, encounter_block, recorded_dttm)|>
  fill(t_rose_first, .direction = "downup") |> #same value for all time points
  fill(hospitalization_id, .direction = "downup") |>
  #Pick in 24h prior to enrollment
   filter(as.POSIXct(recorded_dttm)>=as.POSIXct(t_rose_first)-dhours(24) & 
           as.POSIXct(recorded_dttm)<=as.POSIXct(t_rose_first)) |> 
  mutate(sofa_rass=case_when(numerical_value>-1~0,  numerical_value==-1~1, numerical_value==-2~2, numerical_value==-3~3, numerical_value==-4 | numerical_value==-5~4)) |> 
  collect()

min_rass<- sofa_rass |>
  group_by(patient_id, encounter_block) |>
  mutate(min_rass=min(numerical_value, na.rm = TRUE)) |>
  filter(row_number()==1) |>
  select(patient_id, encounter_block, min_rass) |> 
  ungroup()

sofa_rass<- sofa_rass |>
  group_by(patient_id, encounter_block) |>
  mutate(max_sofa_rass=max(sofa_rass, na.rm = TRUE)) |>
  filter(row_number()==1) |>
  select(patient_id, encounter_block, max_sofa_rass) 

#Calculate Lowest MAP 24h prior to enrollment for SOFA
sofa_map <- clif_vitals |>
  filter(vital_category %in% c('map')) |>
  filter(hospitalization_id %in% cohort_hospitalization_ids$hospitalization_id) |>
  #Filter Outliers MAP>250
  filter(vital_value<=250) |>
  collect() |>
  join(cohort_hospitalization_ids, how = 'left') |>
  join(cohort_times, how = 'left') |>
  #Pick Lowest MAP in 24h prior to enrollment
  filter(as.POSIXct(recorded_dttm)>=as.POSIXct(t_rose_first)-dhours(24) & 
           as.POSIXct(recorded_dttm)<=as.POSIXct(t_rose_first)) |>
  mutate(sofa_map=case_when(vital_value<70~1, vital_value>=70~0)) |>
  group_by(patient_id, encounter_block) |>
  mutate(max_sofa_map=max(sofa_map, na.rm = TRUE)) |>
  filter(row_number()==1) |>
  select(patient_id, encounter_block, max_sofa_map) |> #, norepi_dose, epi_dose, vaso_dose, angiotensin_dose, dopa_dose, phenyl_dose) |>
  ungroup()

#Calculate highest bilirubin in 24h prior to enrollment for sofa
sofa_bili <- clif_labs |>
  filter(lab_category %in% c('bilirubin_total')) |>
  filter(hospitalization_id %in% cohort_hospitalization_ids$hospitalization_id) |>
  #Filter Outliers  
  filter(lab_value_numeric<=80) |>
  collect() |>
  join(cohort_hospitalization_ids, how = 'left') |>
  join(cohort_times, how = 'left') |>
  #Pick in 24h prior to enrollment
  filter(as.POSIXct(lab_collect_dttm)>=as.POSIXct(t_rose_first)-dhours(24) & 
           as.POSIXct(lab_collect_dttm)<=as.POSIXct(t_rose_first)) |>
  mutate(sofa_bili=case_when(lab_value_numeric<1.2~0,  lab_value_numeric>=1.2 & lab_value_numeric<2~1, lab_value_numeric>=2 & lab_value_numeric<6~2, lab_value_numeric>=6 & lab_value_numeric<12~3, lab_value_numeric>=12~4)) |> 
  group_by(patient_id, encounter_block) |>
  mutate(max_sofa_bili=max(sofa_bili, na.rm = TRUE)) |>
  filter(row_number()==1) |>
  select(patient_id, encounter_block, max_sofa_bili) |> 
  ungroup()

#Calculate lowest platelets in 24h prior to enrollment for sofa
sofa_plt <- clif_labs |>
  filter(lab_category %in% c('platelet_count')) |>
  filter(hospitalization_id %in% cohort_hospitalization_ids$hospitalization_id) |>
  #Filter Outliers 
  filter(lab_value_numeric<=2000) |>
  collect() |>
  join(cohort_hospitalization_ids, how = 'left') |>
  join(cohort_times, how = 'left') |>
  #Pick Lowest in 24h prior to enrollment
  filter(as.POSIXct(lab_collect_dttm)>=as.POSIXct(t_rose_first)-dhours(24) & 
           as.POSIXct(lab_collect_dttm)<=as.POSIXct(t_rose_first)) |> 
  mutate(sofa_plt=case_when(lab_value_numeric<20~4,  lab_value_numeric>=20 & lab_value_numeric<50~3, lab_value_numeric>=50 & lab_value_numeric<100~2, lab_value_numeric>=100 & lab_value_numeric<150~1, lab_value_numeric>=150~0)) |> 
  group_by(patient_id, encounter_block) |>
  mutate(max_sofa_plt=max(sofa_plt, na.rm = TRUE)) |>
  filter(row_number()==1) |>
  select(patient_id, encounter_block, max_sofa_plt) |> 
  ungroup()

#Calculate highest cr in 24h prior to enrollment for sofa
sofa_cr <- clif_labs |>
  filter(lab_category %in% c('creatinine')) |>
  filter(hospitalization_id %in% cohort_hospitalization_ids$hospitalization_id) |>
  #Filter Outliers 
  filter(lab_value_numeric<=20) |>
  collect() |>
  join(cohort_hospitalization_ids, how = 'left') |>
  join(cohort_times, how = 'left') |>
  #Pick Lowest in 24h prior to enrollment
  filter(as.POSIXct(lab_collect_dttm)>=as.POSIXct(t_rose_first)-dhours(24) & 
           as.POSIXct(lab_collect_dttm)<=as.POSIXct(t_rose_first)) |> 
  mutate(sofa_cr=case_when(lab_value_numeric<1.2~0,  lab_value_numeric>=1.2 & lab_value_numeric<2~1, lab_value_numeric>=2 & lab_value_numeric<3.5~2, lab_value_numeric>=3.5 & lab_value_numeric<5~3, lab_value_numeric>=5~4)) |> 
  group_by(patient_id, encounter_block) |>
  mutate(max_sofa_cr=max(sofa_cr, na.rm = TRUE)) |>
  filter(row_number()==1) |>
  select(patient_id, encounter_block, max_sofa_cr) |> 
  ungroup()

#SARS COV2 Positivity - Do this At Patient Level Anytime in the 4 Weeks Prior to t_enrollment, up until enrollment (misses labs that return after time of enrollment - sets to COVID negative, reflecting clinicians knowledge at time of meeting criteria)
sars_cov2 <- clif_microbiology_nonculture |>
  filter(patient_id %in% cohort_times$patient_id) |>
  select(-hospitalization_id) |> #Want to Merge on Patient Level
  filter(tolower(organism_category) %in% c('sars_cov2', 'sars cov2')) |>
  left_join(cohort_hospitalization_ids) |> #Merges in Encounter Block
  left_join(cohort_times) |>
  collect() |>
  filter(collect_dttm<=t_rose_first  & collect_dttm>=t_rose_first-dweeks(4)) |>
  group_by(patient_id, encounter_block) |>
  mutate(sars_cov2_positive=fifelse(
    sum(tolower(result_category)=='detected', na.rm=TRUE)>=1, 1, 0)) |>
  filter(row_number()==1) |>
  select(patient_id, encounter_block, sars_cov2_positive)

#Calculate lowest pH 24h prior to enrollment (ABG or VBG)
pH <- clif_labs |>
  filter(tolower(lab_category) %in% c('ph_arterial', 'ph_venous')) |>
  filter(hospitalization_id %in% cohort_hospitalization_ids$hospitalization_id) |>
  #Filter Outliers  
  filter(lab_value_numeric<=8.2 & lab_value_numeric>=6.4 ) |>
  collect() |>
  join(cohort_hospitalization_ids, how = 'left') |>
  join(cohort_times, how = 'left') |>
  #Pick in 24h prior to enrollment
  filter(as.POSIXct(lab_collect_dttm)>=as.POSIXct(t_rose_first)-dhours(24) & 
           as.POSIXct(lab_collect_dttm)<=as.POSIXct(t_rose_first)) |>
  group_by(patient_id, encounter_block) |>
  mutate(min_ph=min(lab_value_numeric, na.rm = TRUE)) |>
  filter(row_number()==1) |>
  select(patient_id, encounter_block, min_ph) |> 
  ungroup()

paralytic_start_all <- paralytic_start_all |>
  select(hospitalization_id, med_category_c, patient_id, encounter_block, paralytic_start_time_c, ett_to_paralytic_c, ratio_at_paralytics_c, para_route, med_category_i, paralytic_start_time_i, ett_to_paralytic_i, para_route_i, intermittent_para, ratio_at_paralytics_i) |>
    rename(continous_paralytic_given = med_category_c, paralytic_start_time_c_all= paralytic_start_time_c, ett_to_paralytic_c_all=ett_to_paralytic_c, any_continuous=para_route, ratio_at_paralytics_c_all=ratio_at_paralytics_c, intermittent_paralytic_given = med_category_i, paralytic_start_time_i_all=paralytic_start_time_i, ett_to_paralytic_i_all=ett_to_paralytic_i, any_intermittent=para_route_i, intermittent_para_all=intermittent_para, ratio_at_paralytics_i_all=ratio_at_paralytics_i) 

rose_analytic_data <- hospitalization_vars |>
  left_join(demos) |>
  left_join(hospital_location) |>
  left_join(bmi) |>
  left_join(final_cohort_rose_rose) |>
  left_join(vent_times) |>
  left_join(prone_episodes) |>
  left_join(pH) |>
  left_join(code_status_rose) |>
  left_join(set_rr) |>
  left_join(set_tv) |>
  left_join(mv_obs) |>
  left_join(plat) |>
  left_join(norepi_equivalent) |>
  left_join(min_rass) |>
  left_join(sofa_pressors) |>
  left_join(sofa_map) |>
  left_join(sofa_rass) |>
  left_join(sofa_gcs) |>
  left_join(sofa_bili) |>
  left_join(sofa_cr) |>
  left_join(sofa_plt) |>
  left_join(sars_cov2) |>
  left_join(paralytic_start_all)|>

  #IF norepi equivalent is missing it means patient had no vasoactives recorded
  mutate(nee_pressor_dose=fifelse(is.na(nee_pressor_dose), 0, nee_pressor_dose)) |>
  mutate(max_sofa_pressor=fifelse(is.na(max_sofa_pressor), 0, max_sofa_pressor)) |>
  mutate(max_sofa_bili=fifelse(is.na(max_sofa_bili), 0, max_sofa_bili)) |>
  mutate(max_sofa_plt=fifelse(is.na(max_sofa_plt), 0, max_sofa_plt)) |>
  mutate(max_sofa_cr=fifelse(is.na(max_sofa_cr), 0, max_sofa_cr)) |>
  mutate(max_sofa_map=fifelse(is.na(max_sofa_map), 0, max_sofa_map)) |>
  mutate(max_sofa_hemodynamics=case_when(max_sofa_pressor>1~max_sofa_pressor, max_sofa_pressor<2~max_sofa_map)) |> 
  mutate(max_sofa_ams=case_when(max_sofa_gcs>=max_sofa_rass | is.na(max_sofa_rass)~max_sofa_gcs, max_sofa_gcs<max_sofa_rass | is.na(max_sofa_gcs)~max_sofa_rass, is.na(max_sofa_gcs) & is.na(max_sofa_gcs)~0)) |> 
  mutate(sofa_score=max_sofa_plt + max_sofa_ams + max_sofa_bili + max_sofa_hemodynamics + max_sofa_cr) |>
  select(-hospitalization_id) |>
  #Race and ethnicity mappings: 1=white, non hispanic, 2=hispanic, regardless of race, 3=black non-hispanic, 4=asian, non-hispanic, 5=other, 6=Unknown
  mutate(race_ethnicity=fcase(
    tolower(race_category)=="white" & 
      tolower(ethnicity_category) %in% c('non-hispanic'), 'White, non-Hispanic',
    tolower(ethnicity_category)=='hispanic', 'Hispanic',
    tolower(race_category)=='black or african american' & 
      tolower(ethnicity_category) %in% c('non-hispanic'), 'Black, non-Hispanic',
    tolower(race_category)=='asian', 'Asian',
    tolower(race_category) %!in% c('white', 'black or african american', 'asian', 'unknown'), 'other',
    tolower(race_category) == "unknown" | is.na(race_category) |
    tolower(ethnicity_category) == "unknown" | is.na(ethnicity_category), "unknown")) |>
  #select(-mode_category, -device_category) |>
  #Calculate Time from Admission to Enrollment
  mutate(days_admit_to_enroll=as.duration(t_rose_first-final_admission_dttm)/ddays(1)) |>
  distinct()
#rm(bmi, demos, hospitalization_vars, hospital_location, min_pf, norepi_equivalent)

#calculate minimum time to start paralytic (whether intermittent or continuous)
rose_analytic_data <- rose_analytic_data |>
  mutate(criteria_to_paralytic_c = as.numeric(criteria_to_paralytic_c, units = "hours"), 
         criteria_to_paralytic_i_rose= as.numeric(criteria_to_paralytic_i_rose, units = "hours"), 
         ett_to_paralytic_c = as.numeric(ett_to_paralytic_c, units = "hours"), 
         ett_to_paralytic_i_rose = as.numeric(ett_to_paralytic_i_rose, units = "hours"), 
    criteria_to_paralytic=pmin(criteria_to_paralytic_c, criteria_to_paralytic_i_rose, na.rm=TRUE), 
         ett_to_paralytic=pmin(ett_to_paralytic_c, ett_to_paralytic_i_rose, na.rm=TRUE))

#clean up missing data
write_csv(rose_analytic_data, paste0(project_location, '/project_tables/rose_analytic_data.parquet'))
rose_analytic_data <- rose_analytic_data |>
  mutate(first_rose_mode= case_when(first_rose_mode=="Assist Control-Volume Control" | first_rose_mode=="Pressure-Regulated Volume Control" | first_rose_mode=="Pressure Control" ~first_rose_mode, first_rose_mode=="Other"| first_rose_mode=="Pressure Support/CPAP" | first_rose_mode=="Blow by" | first_rose_mode=="Volume Support"~"Other", first_rose_mode=="SIMV"~"SIMV")) 


write_parquet(rose_analytic_data, paste0(project_location, '/project_tables/rose_analytic_data.parquet'))

gc()
```


```{r}
## Export the list of `hospitalization_id` for the identified patients
hospitalization_ids<- rose_analytic_data |>
  select(patient_id, encounter_block) |>
  mutate(keep=1)

cohort_hospitalization_ids <- cohort_hospitalization_ids |>
  left_join(hospitalization_ids) |>
  filter(keep==1) |>
  select(-keep)
  
save(cohort_hospitalization_ids, file = paste0(project_location, "/project_tables/cohort_hospitalization_ids.RData"))

toc() #End R time
```

